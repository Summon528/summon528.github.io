[{"title":"[UVA] 796 - Critical Links","url":"/2018/01/01/UVA-796-Critical-Links/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=737\n### 題意\n找橋\n### 思路\nTarjan\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nvector<vector<int>> g;\nvector<int> dfs_num, dfs_lo;\nvector<pair<int, int>> ans;\nint cnt;\n\nint dfs(int s, int t) {\n    dfs_num[t] = dfs_lo[t] = cnt++;\n    for (auto i : g[t]) {\n        if (dfs_num[i] == -1) {\n            dfs(t, i);\n            if (dfs_lo[i] > dfs_num[t]) {\n                pair<int, int> p;\n                if (t > i) {\n                    p = make_pair(i, t);\n                } else {\n                    p = make_pair(t, i);\n                }\n                ans.push_back(p);\n            }\n            dfs_lo[t] = min(dfs_lo[t], dfs_lo[i]);\n        } else if (s != i) {\n            dfs_lo[t] = min(dfs_lo[t], dfs_num[i]);\n        }\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n) {\n        int s, t, k;\n        g.clear();\n        g.resize(n);\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d (%d)\", &s, &k);\n            for (int i = 0; i < k; i++) {\n                cin >> t;\n                g[s].push_back(t);\n            }\n        }\n        dfs_num.clear();\n        dfs_num.resize(n, -1);\n        dfs_lo.clear();\n        dfs_lo.resize(n);\n        ans.clear();\n        cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (dfs_num[i] == -1) dfs(-1, i);\n        }\n        sort(ans.begin(), ans.end());\n        printf(\"%d critical links\\n\", ans.size());\n        for (auto i : ans) {\n            printf(\"%d - %d\\n\", i.first, i.second);\n        }\n        puts(\"\");\n    }\n}\n```\n","tags":["Graph"]},{"title":"[UVA] 315 - Network","url":"/2018/01/01/UVA-315-Network/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=251\n### 題意\n找節點\n### 思路\nTarjan\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nvoid dfs(int x, vector<vector<int>> &g, vector<int> &dfs_lo,\n         vector<int> &dfs_num, vector<int> &dfs_par, int &cnt,\n         vector<bool> &ans, int &root_kids, int &root) {\n    dfs_lo[x] = dfs_num[x] = cnt++;\n    for (auto i : g[x]) {\n        if (dfs_num[i] == -1) {\n            if (x == root) root_kids++;\n            dfs_par[i] = x;\n            dfs(i, g, dfs_lo, dfs_num, dfs_par, cnt, ans, root_kids, root);\n            if (dfs_lo[i] >= dfs_num[x]) {\n                ans[x] = 1;\n            }\n            dfs_lo[x] = min(dfs_lo[i], dfs_lo[x]);\n        } else if (dfs_par[x] != i) {\n            dfs_lo[x] = min(dfs_lo[x], dfs_num[i]);\n        }\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<vector<int>> g(n);\n        int m;\n        while (cin >> m, m) {\n            m--;\n            string s;\n            getline(cin, s);\n            stringstream ss(s);\n            int tmp;\n            while (ss >> tmp) g[m].push_back(tmp - 1), g[tmp - 1].push_back(m);\n        }\n        vector<int> dfs_lo(n), dfs_num(n, -1), dfs_par(n, -1);\n        vector<bool> ans(n);\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (dfs_num[i] == -1) {\n                int root_kids = 0;\n                dfs(i, g, dfs_lo, dfs_num, dfs_par, cnt, ans, root_kids, i);\n                ans[i] = (root_kids > 1);\n            }\n        }\n        // cout << \"ans:\" << ans << endl;\n        cout << count(ans.begin(), ans.end(), 1) << endl;\n    }\n}\n```\n","tags":["Graph"]},{"title":"[UVA] 11396 - Claw Decomposition","url":"/2018/01/01/UVA-11396-Claw-Decomposition/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2391\n### 題意\n\n### 思路\n二分圖判斷\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <queue>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int V;\n    while (cin >> V, V) {\n        int a, b;\n        vector<vector<int>> g(V);\n        while (cin >> a >> b, a | b) {\n            a--, b--;\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<int> color(V, -1);\n        queue<int> q;\n        q.push(0);\n        color[0] = 0;\n        bool bi = true;\n        while (!q.empty() && bi) {\n            int tmp = q.front();\n            q.pop();\n            for (auto i : g[tmp]) {\n                if (color[i] == -1) {\n                    color[i] = 1 - color[tmp];\n                    q.push(i);\n                } else if (color[i] == color[tmp]) {\n                    bi = false;\n                    break;\n                }\n            }\n        }\n        bi ? cout << \"YES\" << endl : cout << \"NO\" << endl;\n    }\n}\n```\n"},{"title":"[UVA] 11080 - Place the Guards","url":"/2018/01/01/UVA-11080-Place-the-Guards/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2021\n### 題意\n\n### 思路\n二分圖\n<!--more-->\n### 程式碼\n```python\nfrom collections import deque\n\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        v, e = map(int, input().split())\n        g = [[0] * v for _ in range(v)]\n        for i in range(e):\n            a, b = map(int, input().split())\n            if not g[a][b]:\n                g[a][b] = 1\n                g[b][a] = 1\n        color = [-1] * v\n        check = True\n        ans = 0\n        for idx, item in enumerate(color):\n            if not check:\n                break\n            if item == -1:\n                q = deque()\n                q.append(idx)\n                color[idx] = 0\n                cnt = [1, 0]\n                while q and check:\n                    tmp = q.popleft()\n                    for i in range(v):\n                        if g[tmp][i]:\n                            if color[i] == -1:\n                                q.append(i)\n                                color[i] = 1 - color[tmp]\n                                cnt[1 - color[tmp]] += 1\n                            elif color[i] == color[tmp]:\n                                check = False\n                                break\n                ans += max(1, min(cnt))\n        if check:\n            print(ans)\n        else:\n            print(-1)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["Bipartite"]},{"title":"[UVA] 10004 - Bicoloring","url":"/2018/01/01/UVA-10004-Bicoloring/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=945\n### 題意\n\n### 思路\n判斷二分圖\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <queue>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int n, l;\n    while (cin >> n, n) {\n        vector<vector<int>> v(n);\n        cin >> l;\n        for (int i = 0; i < l; i++) {\n            int a, b;\n            cin >> a >> b;\n            v[a].push_back(b);\n        }\n\n        queue<int> q;\n        vector<int> color(n, -1);\n        q.push(0);\n        color[0] = 0;\n        bool check = true;\n        while (!q.empty() && check) {\n            int tmp = q.front();\n            q.pop();\n            for (int i = 0; i < v[tmp].size(); i++) {\n                if (color[v[tmp][i]] == -1) {\n                    q.push(v[tmp][i]);\n                    color[v[tmp][i]] = 1 - color[tmp];\n                } else if (color[v[tmp][i]] == color[tmp]) {\n                    check = false;\n                    break;\n                }\n            }\n        }\n        check ? cout << \"BICOLORABLE.\" << endl\n              : cout << \"NOT BICOLORABLE.\" << endl;\n    }\n}\n```\n","tags":["Bipartite"]},{"title":"[UVA] 11060 - Beverages","url":"/2018/01/01/UVA-11060-Beverages/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2001\n### 題意\n\n### 思路\n拓樸排序 注意輸出順序是唯一的\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nbool dfs(int x, vector<int> &path, vector<vector<int>> &g, vector<int> &ref,\n         int N) {\n    if (path.size() == N) return true;\n    for (int i = 0; i < N; i++) {\n        if (g[x][i]) ref[i]--;\n    }\n    for (int i = 0; i < N; i++) {\n        if (ref[i] == 0) {\n            path.push_back(i);\n            ref[i]--;\n            if (dfs(i, path, g, ref, N)) return true;\n            ref[i]++;\n            path.pop_back();\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        if (g[x][i]) ref[i]++;\n    }\n    return false;\n}\n\nint main() {\n    int N, kase = 1;\n    while (cin >> N) {\n        vector<string> vs;\n        unordered_map<string, int> um;\n        vector<vector<int>> graph(N, vector<int>(N));\n        vector<int> ref(N);\n        for (int i = 0; i < N; i++) {\n            string s;\n            cin >> s;\n            um[s] = i;\n            vs.push_back(s);\n        }\n        int M;\n        cin >> M;\n        for (int i = 0; i < M; i++) {\n            string a, b;\n            cin >> a >> b;\n            if (!graph[um[a]][um[b]]) {\n                graph[um[a]][um[b]] = 1;\n                ref[um[b]]++;\n            }\n        }\n\n        vector<int> path;\n        for (int i = 0; i < N; i++) {\n            if (ref[i] == 0) {\n                ref[i]--;\n                path.push_back(i);\n                dfs(i, path, graph, ref, N);\n                break;\n            }\n        }\n\n        cout << \"Case #\" << kase++\n             << \": Dilbert should drink beverages in this order:\";\n        for (auto i : path) {\n            cout << \" \" << vs[i];\n        }\n        cout << '.' << endl << endl;\n    }\n}\n```\n","tags":["Topological Sort"]},{"title":"[UVA] 872 - Ordering","url":"/2018/01/01/UVA-872-Ordering/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=813\n### 題意\n\n### 思路\n拓樸排序\n<!--more-->\n### 程式碼\n```python\ndef dfs(x, graph, path, ref, ans, N):\n    if ref[x] == -1:\n        return\n\n    ref[x] -= 1\n    path.append(x)\n\n    if len(path) == N:\n        ans.append(list(map(lambda x: chr(x + ord('A')), path)))\n        ref[x] += 1\n        path.pop()\n        return\n\n    for idx, item in enumerate(graph[x]):\n        if item:\n            ref[idx] -= 1\n\n    for idx, item in enumerate(ref):\n        if item == 0:\n            dfs(idx, graph, path, ref, ans, N)\n\n    for idx, item in enumerate(graph[x]):\n        if item:\n            ref[idx] += 1\n\n    ref[x] += 1\n    path.pop()\n\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        input()\n        varss = list(map(lambda x: ord(x) - ord('A'), input().split()))\n        graph = [[0] * 26 for _ in range(26)]\n        ref = [-1] * 26\n        con = input().split()\n\n        for i in varss:\n            ref[i] = 0\n\n        for i in con:\n            a = ord(i[0]) - ord('A')\n            b = ord(i[2]) - ord('A')\n            graph[a][b] = 1\n            ref[b] += 1\n\n        ans = []\n        for idx, item in enumerate(ref):\n            if item == 0:\n                dfs(idx, graph, [], ref, ans, len(varss))\n\n        if t != 0:\n            print('')\n\n        if ans:\n            for i in ans:\n                print(*i)\n        else:\n            print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["Topological Sort"]},{"title":"[UVA] 11953 - Battleships","url":"/2017/12/24/UVA-11953-Battleships/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3104\n### 題意\n問還剩下幾艘船\n### 思路\n遇到x就DFS\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\nvoid dfs(int x, int y, vector<string> &g) {\n    if (g[x][y] == '.') return;\n    g[x][y] = '.';\n    dfs(x + 1, y, g);\n    dfs(x, y + 1, g);\n    dfs(x, y - 1, g);\n    dfs(x - 1, y, g);\n}\n\nint main() {\n    int T;\n    cin >> T;\n    for (int t = 1; t <= T; t++) {\n        int N;\n        cin >> N;\n        vector<string> g;\n        string s;\n        g.push_back(string(N + 2, '.'));\n        for (int i = 0; i < N; i++) {\n            cin >> s;\n            g.push_back('.' + s + '.');\n        }\n        g.push_back(string(N + 2, '.'));\n        int cnt = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (g[i][j] == 'x') {\n                    cnt++;\n                    dfs(i, j, g);\n                }\n            }\n        }\n        cout << \"Case \" << t << \": \" << cnt << endl;\n    }\n}\n```\n","tags":["DFS"]},{"title":"[UVA] 11094 - Continents","url":"/2017/12/24/UVA-11094-Continents/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2035\n### 題意\n每個圖有兩種char，站著的那一點一定是陸地\n問除了自己的那一塊之外，最大的一塊有多大\n這個圖左右連通但上下不連通\n### 思路\nDFS 看懂題目即可\n<!--more-->\n### 程式碼\n```python\nimport math\n\n\ndef dfs(x, y, target, graph, visit, X, Y, M, N):\n    if x == X and y == Y:\n        return -math.inf\n    if visit[x][y]:\n        return 0\n    visit[x][y] = True\n    cnt = 0\n    if graph[x + 1][y] == target:\n        cnt += dfs(x + 1, y, target, graph, visit, X, Y, M, N)\n    if graph[x][(y + 1) % N] == target:\n        cnt += dfs(x, (y + 1) % N, target, graph, visit, X, Y, M, N)\n    if graph[x][y - 1 if y - 1 >= 0 else N - 1] == target:\n        cnt += dfs(x, y - 1 if y - 1 >= 0 else N - 1,\n                   target, graph, visit, X, Y, M, N)\n    if graph[x - 1][y] == target:\n        cnt += dfs(x - 1, y, target, graph, visit, X, Y, M, N)\n    return cnt + 1\n\n\ndef main():\n    while True:\n        try:\n            M, N = map(int, input().split())\n        except EOFError:\n            break\n        graph = []\n        graph.append(list('$' * N))\n        for _ in range(M):\n            graph.append(list(input()))\n        graph.append(list('$' * N))\n        vis = [[False] * (N) for _ in range(M + 2)]\n        X, Y = map(int, input().split())\n        X += 1\n        target = graph[X][Y]\n        Max = 0\n        for i in range(1, M + 1):\n            for j in range(N):\n                if graph[i][j] == target and not vis[i][j]:\n                    Max = max(Max, dfs(i, j, target, graph, vis, X, Y, M, N))\n        print(Max)\n        input()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["DFS"]},{"title":"[UVA] 1103 - Ancient Messages","url":"/2017/12/24/UVA-1103-Ancient-Messages/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3544\n### 題意\n識別每個圖案各有幾個\n### 思路\n注意到每個圖案内的白色區塊分別是0~5個\n先把16進位解壓成01二位陣列後（外面要包一圈0以保證背景聯通）\n用BFS將背景都該成大便圖案💩\n之後枚舉每個點，若是1則BFS將他們改成漢堡圖案🍔\n在進行以上步驟的時候，如果遇到0則也把他們塗成大便並記錄數量\n<!--more-->\n### 程式碼\n```python\nfrom collections import deque\n\n\ndef bfs_fill(x, y, curr, change_to, graph, visit, bg=False):\n    dq = deque([(x, y)])\n    visit[x][y] = True\n    graph[x][y] = change_to\n    dxy = ((1, -1), (1, 0), (1, 1), (0, -1),\n           (0, 1), (-1, -1), (-1, 0), (-1, 1))\n    cnt = 0\n    while dq:\n        tmp = dq.popleft()\n        for i in dxy:\n            tx = tmp[0] + i[0]\n            ty = tmp[1] + i[1]\n            try:\n                if graph[tx][ty] == curr and not visit[tx][ty]:\n                    graph[tx][ty] = change_to\n                    dq.append((tx, ty))\n                if not bg and graph[tx][ty] == '0':\n                    bfs_fill(tx, ty, '0', '💩', graph, visit)\n                    cnt += 1\n            except IndexError:\n                continue\n    return cnt\n\n\ndef main():\n    kase = 1\n    while True:\n        H, W = map(int, input().split())\n        if H == 0 and W == 0:\n            break\n        W *= 4\n        graph = []\n        visit = [[False] * (W + 2) for i in range(H + 2)]\n        graph.append(list('0' * (W + 2)))\n        for _ in range(H):\n            graph.append(list('0' + str(bin(int(input(), 16))\n                                        [2:].rjust(W, '0')) + '0'))\n\n        graph.append(list('0' * (W + 2)))\n        bfs_fill(0, 0, '0', '💩', graph, visit, True)\n        cnt = [0] * 6\n        for i in range(H + 2):\n            for j in range(W + 2):\n                if graph[i][j] == '1':\n                    cnt[bfs_fill(i, j, '1', '🍔', graph, visit)] += 1\n        print(\"Case {}: {}\".format(kase,\n                                   'A' * cnt[1] + 'D' * cnt[5] +\n                                   'J' * cnt[3] + 'K' * cnt[2] +\n                                   'S' * cnt[4] + 'W' * cnt[0]))\n        kase += 1\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["BFS"]},{"title":"[UVA] 12442 - Forwarding Emails","url":"/2017/12/24/UVA-12442-Forwarding-Emails/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3873\n### 題意\n每個人收到郵件都會傳給另一個人\n問傳給哪一個人可以讓最多人看到\n### 思路\n因爲每一個人都衹會傳給一個人\n所以整個是一個鏈子的結構\n先從第一個點開始並記錄從該點開始會經過的點\n（另外記錄，不要把這個跟dfs時用的陣列搞混了）\n再來枚舉所有點 若該點之前走過代表他一定是前面某次的子鏈 就不需要再dfs一次了\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    for (int t = 1; t <= T; t++) {\n        int N;\n        cin >> N;\n        vector<int> adj(N, -1);\n        for (int i = 0; i < N; i++) {\n            int u, v;\n            cin >> u >> v;\n            u--, v--;\n            adj[u] = v;\n        }\n        int Max = 0, Maxp = 0;\n        vector<bool> best_v(N);\n        for (int i = 0; i < N; i++) {\n            if (best_v[i]) continue;\n            vector<bool> visited(N);\n            vector<int> st;\n            st.push_back(i);\n            int cnt = 0;\n            visited[i] = true;\n            best_v[i] = true;\n            while (!st.empty()) {\n                int tmp = st.back();\n                st.pop_back();\n                if (!visited[adj[tmp]]) {\n                    cnt++;\n                    visited[adj[tmp]] = true;\n                    best_v[adj[tmp]] = true;\n                    st.push_back(adj[tmp]);\n                }\n            }\n            if (cnt > Max) {\n                Max = cnt;\n                Maxp = i;\n            }\n        }\n        cout << \"Case \" << t << \": \" << Maxp + 1 << endl;\n    }\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11906 - Knight in a War Grid","url":"/2017/12/24/UVA-11906-Knight-in-a-War-Grid/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3057\n### 題意\n騎士從(0,0)出發，每次走$(\\pm N,\\pm M)$或$(\\pm M,\\pm N)$共八種走發\n不能走到水上，走到一個點記錄該點能走到的點是奇數個還是偶數個\n### 思路\nDFS搜尋\n不過要注意如果N == M或N跟M其中一個是零，有可能會重複算到\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <set>\n#include <utility>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nvoid dfs(int x, int y, vector<int> &dx, vector<int> &dy, int R, int C,\n         vector<vector<bool>> &g, vector<vector<bool>> &visited, int &even,\n         int &odd) {\n    if (visited[x][y]) return;\n    visited[x][y] = true;\n    int cnt = 0;\n    set<pair<int, int>> se;\n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] < R && x + dx[i] >= 0 && y + dy[i] < C &&\n            y + dy[i] >= 0 && !g[x + dx[i]][y + dy[i]]) {\n            if (se.count(make_pair(x + dx[i], y + dy[i])) == 0) {\n                cnt++;\n                se.insert(make_pair(x + dx[i], y + dy[i]));\n            }\n            dfs(x + dx[i], y + dy[i], dx, dy, R, C, g, visited, even, odd);\n        }\n    }\n    for (int i = 0; i < 4; i++) {\n        if (x + dy[i] < R && x + dy[i] >= 0 && y + dx[i] < C &&\n            y + dx[i] >= 0 && !g[x + dy[i]][y + dx[i]]) {\n            if (se.count(make_pair(x + dy[i], y + dx[i])) == 0) {\n                cnt++;\n                se.insert(make_pair(x + dy[i], y + dx[i]));\n            }\n            dfs(x + dy[i], y + dx[i], dy, dx, R, C, g, visited, even, odd);\n        }\n    }\n    cnt % 2 ? odd++ : even++;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    for (int t = 1; t <= T; t++) {\n        int R, C, M, N, W;\n        cin >> R >> C >> M >> N;\n        vector<vector<bool>> g(R, vector<bool>(C));\n        vector<vector<bool>> visited(R, vector<bool>(C));\n        vector<int> dx = {1, 1, -1, -1}, dy = {1, -1, 1, -1};\n        for (int i = 0; i < 4; i++) dx[i] *= M, dy[i] *= N;\n        cin >> W;\n        for (int i = 0; i < W; i++) {\n            int x, y;\n            cin >> x >> y;\n            g[x][y] = true;\n        }\n        int even = 0, odd = 0;\n        dfs(0, 0, dx, dy, R, C, g, visited, even, odd);\n        cout << \"Case \" << t << \": \" << even << ' ' << odd << endl;\n    }\n}\n```\n","tags":["DFS"]},{"title":"[UVA] 1449 - Dominating Patterns","url":"/2017/12/23/UVA-1449-Dominating-Patterns/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=8&category=24&page=show_problem&problem=4195\n### 題意\n問每個pattern在文本出現的次數\n### 思路\nAC自動機 寫一下就AC了\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <cctype>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint chr2int(char c) {\n    if (isupper(c)) {\n        return c - 'A';\n    } else {\n        return c - 'a' + 26;\n    }\n}\n\nclass node {\n   public:\n    vector<int> nxt;\n    int fail, str_idx, hit;\n    node() {\n        nxt.resize(52, -1);\n        fail = hit = -1;\n        str_idx = -1;\n    }\n};\n\nvoid build_trie(string s, int str_idx, vector<node> &trie, int &node_cnt) {\n    int cur = 0;\n    for (char i : s) {\n        if (trie[cur].nxt[chr2int(i)] == -1) {\n            trie[cur].nxt[chr2int(i)] = ++node_cnt;\n        }\n        cur = trie[cur].nxt[chr2int(i)];\n    }\n    trie[cur].str_idx = str_idx;\n}\n\nvoid build_ac(vector<node> &trie) {\n    queue<int> N;\n    N.push(0);\n    while (!N.empty()) {\n        int p = N.front();\n        N.pop();\n        for (int i = 0; i < 52; i++) {\n            if (trie[p].nxt[i] != -1) {\n                int bk = trie[p].fail;\n                while (bk != -1 && trie[bk].nxt[i] == -1) bk = trie[bk].fail;\n                if (bk != -1) {\n                    trie[trie[p].nxt[i]].fail = trie[bk].nxt[i];\n                } else {\n                    trie[trie[p].nxt[i]].fail = 0;\n                }\n                int r = trie[trie[p].nxt[i]].fail;\n                if (trie[r].str_idx != -1) {\n                    trie[trie[p].nxt[i]].hit = r;\n                } else {\n                    trie[trie[p].nxt[i]].hit = trie[r].hit;\n                }\n                N.push(trie[p].nxt[i]);\n            }\n        }\n    }\n}\n\nvoid match(string s, vector<node> &trie, vector<int> &found) {\n    int p = 0;\n    for (char i : s) {\n        while (p != -1 && trie[p].nxt[chr2int(i)] == -1) p = trie[p].fail;\n        if (p != -1) {\n            p = trie[p].nxt[chr2int(i)];\n        }\n        for (int bk = p; bk != -1; bk = trie[bk].hit) {\n            if (trie[bk].str_idx != -1) {\n                found[trie[bk].str_idx] += 1;\n            }\n        }\n        if (p == -1) p = 0;\n    }\n}\nint main() {\n    cin.tie(0);\n    cin.sync_with_stdio(0);\n    int N;\n    while (cin >> N, N) {\n        int node_cnt = 0;\n        string s;\n        vector<node> trie;\n        trie.resize(1000005);\n        vector<int> equv(N, -1);\n        vector<string> vs;\n        for (int i = 0; i < N; i++) {\n            string tmp;\n            cin >> tmp;\n            vs.push_back(tmp);\n            build_trie(tmp, i, trie, node_cnt);\n        }\n        build_ac(trie);\n        vector<int> found(N);\n        cin >> s;\n        match(s, trie, found);\n        int Max = *max_element(begin(found), end(found));\n        cout << Max << endl;\n        for (int i = 0; i < N; i++) {\n            if (found[i] == Max) cout << vs[i] << endl;\n        }\n    }\n}\n```\n","tags":["AC自動機"]},{"title":"[UVA] 10679 - I Love Strings!!","url":"/2017/12/23/UVA-10679-I-Love-Strings/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&category=24&page=show_problem&problem=1620\n### 題意\n給定一個字串和一些pattern\n問每個pattern有沒有出現在字串裡面\n### 思路\n好像隨便寫都會過\n不過我練習一下ac自動機\n<!--more-->\n### 程式碼\n```cpp\n#include <cctype>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint chr2int(char c) {\n    if (isupper(c)) {\n        return c - 'A';\n    } else {\n        return c - 'a' + 26;\n    }\n}\n\nclass node {\n   public:\n    vector<int> nxt;\n    int fail, str_idx, hit;\n    node() {\n        nxt.resize(52, -1);\n        fail = hit = -1;\n        str_idx = -1;\n    }\n};\n\nvoid build_trie(string s, int str_idx, vector<node> &trie, int &node_cnt,\n                vector<int> &equv) {\n    int cur = 0;\n    for (char i : s) {\n        if (trie[cur].nxt[chr2int(i)] == -1) {\n            trie[cur].nxt[chr2int(i)] = ++node_cnt;\n        }\n        cur = trie[cur].nxt[chr2int(i)];\n    }\n    if (trie[cur].str_idx != -1) {\n        equv[str_idx] = trie[cur].str_idx;\n    } else {\n        trie[cur].str_idx = str_idx;\n    }\n}\n\nvoid build_ac(vector<node> &trie) {\n    queue<int> q;\n    q.push(0);\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i = 0; i < 52; i++) {\n            if (trie[p].nxt[i] != -1) {\n                int bk = trie[p].fail;\n                while (bk != -1 && trie[bk].nxt[i] == -1) bk = trie[bk].fail;\n                if (bk != -1) {\n                    trie[trie[p].nxt[i]].fail = trie[bk].nxt[i];\n                } else {\n                    trie[trie[p].nxt[i]].fail = 0;\n                }\n                int r = trie[trie[p].nxt[i]].fail;\n                if (trie[r].str_idx != -1) {\n                    trie[trie[p].nxt[i]].hit = r;\n                } else {\n                    trie[trie[p].nxt[i]].hit = trie[r].hit;\n                }\n                q.push(trie[p].nxt[i]);\n            }\n        }\n    }\n}\n\nvoid match(string s, vector<node> &trie, vector<bool> &found) {\n    int p = 0;\n    for (char i : s) {\n        while (p != -1 && trie[p].nxt[chr2int(i)] == -1) p = trie[p].fail;\n        if (p != -1) {\n            p = trie[p].nxt[chr2int(i)];\n        }\n        for (int bk = p; bk != -1; bk = trie[bk].hit) {\n            if (trie[bk].str_idx != -1) {\n                found[trie[bk].str_idx] = true;\n            }\n        }\n        if (p == -1) p = 0;\n    }\n}\nint main() {\n    cin.tie(0);\n    cin.sync_with_stdio(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int node_cnt = 0, q;\n        string s;\n        vector<node> trie;\n        trie.resize(1000005);\n        cin >> s >> q;\n        vector<int> equv(q, -1);\n        for (int i = 0; i < q; i++) {\n            string tmp;\n            cin >> tmp;\n            build_trie(tmp, i, trie, node_cnt, equv);\n        }\n        build_ac(trie);\n        vector<bool> found(q);\n        match(s, trie, found);\n        for (int i = 0; i < q; i++) {\n            if (found[i] || (equv[i] != -1 && found[equv[i]])) {\n                cout << \"y\\n\";\n            } else {\n                cout << \"n\\n\";\n            }\n        }\n    }\n}\n\n```\n","tags":["AC自動機"]},{"title":"[UVA] 11831 - Sticker Collector Robot","url":"/2017/12/23/UVA-11831-Sticker-Collector-Robot/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&category=24&page=show_problem&problem=2931\n### 題意\n\n### 思路\n照著模擬即可\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int N, M, S;\n    while (cin >> N >> M >> S, N | M | S) {\n        vector<vector<char>> graph(N + 2, vector<char>(M + 2, '#'));\n        char dir;\n        int cx, cy;\n        for (int i = 1; i <= N; i++) {\n            cin.ignore();\n            for (int j = 1; j <= M; j++) {\n                graph[i][j] = cin.get();\n                if (isalpha(graph[i][j])) {\n                    if (graph[i][j] == 'N') {\n                        dir = 0;\n                    } else if (graph[i][j] == 'S') {\n                        dir = 2;\n                    } else if (graph[i][j] == 'L') {\n                        dir = 1;\n                    } else if (graph[i][j] == 'O') {\n                        dir = 3;\n                    }\n                    cx = i, cy = j;\n                }\n            }\n        }\n        int ans = 0;\n        cin.ignore();\n        char c;\n        int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n        while (c = cin.get(), c != '\\n') {\n            if (c == 'F') {\n                if (graph[cx + dx[dir]][cy + dy[dir]] != '#') {\n                    graph[cx][cy] = '.';\n                    cx += dx[dir];\n                    cy += dy[dir];\n                    if (graph[cx][cy] == '*') ans++;\n                }\n            } else if (c == 'D') {\n                dir++;\n                dir %= 4;\n            } else if (c == 'E') {\n                dir--;\n                if (dir == -1) dir = 3;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 12149 - Feynman","url":"/2017/12/23/UVA-12149-Feynman/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3301\n### 題意\n問n*n的正方形有幾個小正方形\n### 思路\n答案就是 $n\\times n+(n-1)\\times(n-1)+(n-2)\\times(n-2)...$\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int T;\n    while (cin >> T, T) {\n        int ans = 0;\n        for (int i = 1; i <= T; i++) {\n            ans += i * i;\n        }\n        cout << ans << endl;\n    }\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10074 - Take the Land","url":"/2017/12/23/UVA-10074-Take-the-Land/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1015\n### 題意\n問最大都是0的矩形\n### 思路\n枚舉開始列跟結束列，壓成一維後算\n參見[UVA 108](/2017/11/22/UVA-108-Maximum-Sum/)\n<!--more-->\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int n,m;\n    while (cin>>n>>m,n|m){\n        vector<vector<int> > g(n,vector<int>(m));\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < m; j++){\n                cin>>g[i][j];\n            }\n        }\n\n        int Max = 0;\n        for (int i = 0; i < n;i++){\n            vector<int> dp(m);\n            for (int j = i; j < n; j++){\n                for (int k = 0; k < m; k++){\n                    dp[k] += g[j][k];\n                }\n                int cnt = 0, Max_cnt = -1000000000;\n                for (int k = 0; k < m; k++){\n                    if (dp[k] == 0) {cnt++;Max_cnt = max(Max_cnt, cnt);}\n                    else {\n                        Max_cnt = max(Max_cnt, cnt);\n                        cnt = 0;\n                    }\n                }\n                Max = max(Max, Max_cnt*(j-i+1));\n            }\n        }\n        cout<<Max<<endl;\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 10700 - Camel trading","url":"/2017/12/23/UVA-10700-Camel-trading/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1641\n### 題意\n給一個只有加和乘的算式，\n可以隨意加括弧，問最大和最小的可能分別是多少\n### 思路\n最大就是先算加再算乘\n最小就是先算乘再算加\n記得long long\n<!--more-->\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        string s;\n        cin >> s;\n        vector<long long int> Max;\n        for (int i = 0; i < s.length(); i++) {\n            if (isdigit(s[i])) {\n                long long int tmp = 0;\n                if (i + 1 < s.length() && isdigit(s[i + 1])) {\n                    tmp = (s[i] - '0') * 10 + (s[i + 1] - '0');\n                    i++;\n                } else\n                    tmp = (s[i] - '0');\n                Max.push_back(tmp);\n            } else if (s[i] == '+') {\n                long long int tmp = Max.back(), tmp2;\n                Max.pop_back();\n                i++;\n                if (i >= s.length()) break;\n                if (i + 1 < s.length() && isdigit(s[i + 1])) {\n                    tmp2 = (s[i] - '0') * 10 + (s[i + 1] - '0');\n                    i++;\n                } else\n                    tmp2 = (s[i] - '0');\n                tmp += tmp2;\n                Max.push_back(tmp);\n            }\n        }\n        vector<long long int> Min;\n        for (int i = 0; i < s.length(); i++) {\n            if (isdigit(s[i])) {\n                long long int tmp = 0;\n                if (i + 1 < s.length() && isdigit(s[i + 1])) {\n                    tmp = (s[i] - '0') * 10 + (s[i + 1] - '0');\n                    i++;\n                } else\n                    tmp = (s[i] - '0');\n                Min.push_back(tmp);\n            } else if (s[i] == '*') {\n                long long int tmp = Min.back(), tmp2;\n                Min.pop_back();\n                i++;\n                if (i >= s.length()) break;\n                if (i + 1 < s.length() && isdigit(s[i + 1])) {\n                    tmp2 = (s[i] - '0') * 10 + (s[i + 1] - '0');\n                    i++;\n                } else\n                    tmp2 = (s[i] - '0');\n                tmp *= tmp2;\n                Min.push_back(tmp);\n            }\n        }\n        long long int Min_s = 0, Max_s = 1;\n        for (int i = 0; i < Max.size(); i++) Max_s *= Max[i];\n\n        for (int i = 0; i < Min.size(); i++) Min_s += Min[i];\n\n        cout << \"The maximum and minimum are \" << Max_s << \" and \" << Min_s\n             << '.' << endl;\n    }\n}\n```\n","tags":["Greedy"]},{"title":"[UVA] 382 - Perfection","url":"/2017/12/23/UVA-382-Perfection/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=318\n### 題意\n給定一個數字，問該數字除了自己以外的因數加總後比自己大、小、還是等於\n### 思路\n隨便亂做\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(){\n    cout<<\"PERFECTION OUTPUT\"<<endl;\n    int n;\n    while (cin >> n, n){\n        cout<<setw(5)<<n<<\"  \";\n        int ans = 0;\n        for (int i = 1; i < n; i++){\n            if (n % i == 0) {\n                ans += i;\n                if (ans > n) break;\n            }\n        }\n        if (ans == n)cout<<\"PERFECT\"<<endl;\n        else if (ans  > n) cout<<\"ABUNDANT\"<<endl;\n        else cout<<\"DEFICIENT\"<<endl;\n\n    }\n    cout<<\"END OF OUTPUT\"<<endl;\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10042 - Smith Numbers","url":"/2017/12/23/UVA-10042-Smith-Numbers/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=983\n### 題意\nSmith Numbers的定義是\n一個數字x的每個質因數的每個位數加總等於x本身每個位數加總\n給定一個數字，問比該數大且不是質數的Smith Numbers　　\n### 思路\n就。。。照著做\n注意的是每個數字的質因數只會有一個大於$\\sqrt{x}$\n所以可以作到根號再檢查剩下的就好\n<!--more-->\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool primeq(long long int x, vector<bool> &isprime, vector<int> &prime){\n    if (x < 40000){\n        if (isprime[x]) return true;\n        else return false;\n    }else{\n        for (int j = 0; j < prime.size() && x > prime[j]*prime[j]; j++){\n            if (x % prime[j] == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nint digadd(int x){\n    int sum=0;\n    while (x){\n        sum+=x%10;\n        x/=10;\n    }\n    return sum;\n}\n\nint main(){\n    vector<bool> isprime(40000,true);\n    for (int i = 2; i < 40000; i++){\n        if (isprime[i]){\n            for (int j = i*i; j < 40000; j+=i){\n                isprime[j] = false;\n            }\n        }\n    }\n\n    vector<int> prime;\n    for (int i =2; i < 40000;i++){\n        if (isprime[i]) prime.push_back(i);\n    }\n\n\n    int T;\n    cin>>T;\n    while(T--){\n        long long n;\n        cin>>n;\n        for (int i = n+1;;i++){\n            if (!primeq(i,isprime,prime)){\n                int a = digadd(i),b = 0, x = i;\n                for (int j = 0; j < prime.size();j++){\n                    while (x%prime[j] == 0) {\n                        b+=digadd(prime[j]);\n                        x/=prime[j];\n                    }\n                }\n                if (x!=1) b+= digadd(x);\n                if(a == b){\n                    cout<<i<<endl;\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n","tags":["Prime"]},{"title":"[UVA] 11292 - Dragon of Loowater","url":"/2017/12/23/UVA-11292-Dragon-of-Loowater/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2267\n### 題意\n給定一個龍頭高度序列和騎士高度序列\n騎士只能砍比自己矮的龍頭\n問可不可以把龍頭都砍了\n### 思路\n將龍頭和騎士兩個陣列排序好後，\n一一對應砍掉，\n最後看騎士夠不夠用即可\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n | m) {\n        vector<int> head(n), knight(m);\n        for (int i = 0; i < n; i++) {\n            cin >> head[i];\n        }\n        for (int i = 0; i < m; i++) {\n            cin >> knight[i];\n        }\n        sort(begin(head), end(head));\n        sort(begin(knight), end(knight));\n        int j = 0, ans = 0;\n        bool good = true;\n        for (int i = 0; i < n; i++) {\n            try {\n                while (knight.at(j) < head[i]) j++;\n                ans += knight.at(j);\n                j++;\n            } catch (exception &e) {\n                good = false;\n                break;\n            }\n        }\n        good ? cout << ans << endl : cout << \"Loowater is doomed!\" << endl;\n    }\n}\n```\n","tags":["Geedy"]},{"title":"[UVA] 11100 - The Trip, 2007","url":"/2017/12/14/UVA-11100-The-Trip-2007/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2041\n### 題意\n給一堆箱子，大的可以包一個小的\n問最少會有幾個箱子外露\n### 思路\n先找出最小會有幾個箱子`k`\n其實就是把序列排序後，最多連續相同的數字\n之後第一箱放`v[0]、v[0+k]、v[0+2k]...`\n第二箱放`v[1]、v[1+k]...`\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int n;\n    bool allfirst = true;\n    while (cin >> n, n) {\n        if (!allfirst) cout << endl;\n        allfirst = false;\n        vector<int> v(n);\n        for (int i = 0; i < n; i++) {\n            cin >> v[i];\n        }\n\n        sort(begin(v), end(v));\n        int tp = v[0], cnt = 1, Max = 1;\n        for (int i = 1; i < n; i++) {\n            if (tp == v[i]) {\n                cnt++;\n                Max = max(cnt, Max);\n            } else {\n                tp = v[i];\n                cnt = 1;\n            }\n        }\n\n        cout << Max << endl;\n        for (int i = 0; i < n; i++) {\n            bool fst = true;\n            for (int j = i; j < n; j += Max) {\n                if (v.at(j) != -1) {\n                    if (!fst) cout << ' ';\n                    cout << v.at(j);\n                    fst = false;\n                }\n                v.at(j) = -1;\n            }\n            if (!fst) cout << endl;\n        }\n    }\n}\n```\n","tags":["Greedy"]},{"title":"[UVA] 12405 - Scarecrow ","url":"/2017/12/14/UVA-12405-Scarecrow/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3836\n### 題意\n一個稻草人可以保護三個點\n問保護所有地需要的最少稻草人\n### 思路\n遇到一個`.`就在他的下一格插一隻稻草人\n<!--more-->\n### 程式碼\n```python\ndef main():\n    T = int(input())\n    for t in range(T):\n        input()\n        field = input()\n        i = ans = 0\n        while i < len(field):\n            if field[i] == '.':\n                ans += 1\n                i += 2\n            i += 1\n        print(\"Case {}: {}\".format(t + 1, ans))\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["Greedy"]},{"title":"[UVA] 11389 - The Bus Driver Problem","url":"/2017/12/14/UVA-11389-The-Bus-Driver-Problem/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2384\n### 題意\n每個司機要開一趟早班跟下午班\n工時超過就要付加班費\n問最少要付的加班費\n### 思路\n排序好，最大的配最小的，第二大配第二小的\n<!--more-->\n### 程式碼\n```python\ndef main():\n    while True:\n        n, d, r = map(int, input().split())\n        if not (n | d | r):\n            break\n        mor = list(map(int, input().split()))\n        aft = list(map(int, input().split()))\n        mor.sort()\n        aft.sort()\n        ans = 0\n        for idx, item in enumerate(mor):\n            ans += max((item + aft[len(aft) - 1 - idx]) - d, 0)\n        ans *= r\n        print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["Greedy"]},{"title":"[UVA] 11264 - Coin Collector","url":"/2017/12/14/UVA-11264-Coin-Collector/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2231\n### 題意\n領錢銀行會先用最大的幣值給，再用比較小的\n給定一些些硬幣種類，問最多可以拿到幾種硬幣\n### 思路\n遍歷所有硬幣，並記錄當前總和\n若當前總和小於下一個硬幣 則答案++\n<!--more-->\n### 程式碼\n```python\nimport math\n\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        input()\n        C = list(map(int, input().split()))\n        C.append(math.inf)\n        ans = Sum = 0\n        for idx, item in enumerate(C[:-1]):\n            if Sum + item < C[idx + 1]:\n                Sum += item\n                ans += 1\n        print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["Greedy"]},{"title":"[UVA] 10943 - How do you add?","url":"/2017/12/13/UVA-10943-How-do-you-add/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1884\n### 題意\n問K個數字湊到N有幾個方法\n### 思路\n高中數學  \n相當於求 $x_1+x_2+x_3+...+x_k = N$的方法數<!--more-->    \n答案即C N+K-1 取 K-1  \n好像應該先預處理比較快，不過數字這麼小Python又這麼棒，隨便寫寫  \n### 程式碼\n```python\nimport math\n\ndef main():\n    while True:\n        N, K = map(int, input().split())\n        if N == 0 and K == 0:\n            break\n        print((math.factorial(N + K - 1) //\n               math.factorial(K - 1) // math.factorial(N)) % 1000000)\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["UVA"]},{"title":"[UVA] 10721 - Bar Codes","url":"/2017/12/13/UVA-10721-Bar-Codes/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1662\n### 題意\nBC(n,k,m)代表有k段組合的寬度剛好為n、且最寬的一段不超過m    \n黑的白的都算一段 且第一段一定要是黑的(不然會當作長度比較小的)  \n### 思路\nDP D起來  \n可以一開始就預處理所有情況<!--more-->  \n先設置所有`bc[0][0][i] = 1`  \n`bc[n][k][m]` = 第二個1在第二格情況的總和 + 第二個1在第三格情況的總和 ...  \n`bc[n][k][m] = bc[n - 1][k - 1][m] + bc[n - 2][k - 1][m] ...`\n### 程式碼\n```c\n#include <stdio.h>\n#include <string.h>\n#define INF 1000000000\n\nint main() {\n    int i, n, k, m;\n    long long int bc[51][51][51];\n    memset(bc, 0, sizeof(bc));\n    for (i = 0; i <= 50; i++) bc[0][0][i] = 1;\n    for (n = 1; n <= 50; n++) {\n        for (k = 1; k <= 50; k++) {\n            for (m = 1; m <= 50; m++) {\n                if (m > n) {\n                    bc[n][k][m] = bc[n][k][n];\n                    continue;\n                }\n                for (i = 1; i <= n && i <= m; i++)\n                    bc[n][k][m] += bc[n - i][k - 1][m];\n            }\n        }\n    }\n\n    int N, K, M;\n    while (~scanf(\"%d %d %d\", &N, &K, &M)) printf(\"%lld\\n\", bc[N][K][M]);\n    return 0;\n}\n```\n","tags":["DP"]},{"title":"[UVA] 10337 - Flight Planner","url":"/2017/12/13/UVA-10337-Flight-Planner/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1278\n### 題意\n給定每個空層每100miles的風速  \n飛機每100miles可以選擇平飛、往上飛一層、往下飛一層  \n花費燃料分別為30、60、20，若有風還要-w  \n問從起點到終點花費最少燃料  \n注意空層的數值是從9給到0\n### 思路\nDP `dp[i][j]` 存飛機飛到第j段、且剛好在第i空層花費的最少燃料  \n枚舉j、i 飛機每次只能從前一段的上面一層、平層、下面一層飛來  取最小值  \n注意飛機不能在地上爬、不能鑽地洞、不能飛超過九層  \n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        int X;\n        cin >> X;\n        X /= 100;\n        vector<vector<int>> wind(10, vector<int>(X + 1));\n        for (int i = 9; i >= 0; i--)\n            for (int j = 0; j < X; j++) cin >> wind[i][j];\n\n        vector<vector<int>> dp(10, vector<int>(X + 1, INF));\n        dp[0][0] = 0;\n        for (int j = 1; j <= X; j++) {\n            for (int i = 0; i < 10; i++) {\n                int Min = INF;\n                if (i > 0) {\n                    Min = min(Min, dp[i - 1][j - 1] + 60 - wind[i - 1][j - 1]);\n                    Min = min(dp[i][j - 1] + 30 - wind[i][j - 1], Min);\n                }\n                if (i < 9)\n                    Min = min(Min, dp[i + 1][j - 1] + 20 - wind[i + 1][j - 1]);\n                dp[i][j] = Min;\n            }\n        }\n        cout << dp[0][X] << endl << endl;\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 11284 - Shopping Trip","url":"/2017/12/13/UVA-11284-Shopping-Trip/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2259\n### 題意\n給定一張圖包含商家及起點  \n每走一條邊都要花費一定的油費  \n再給定一些有自己想要的電影的商店並給定若在該店拿片子能獲利多少  \n問如何能有最大獲利 (旅程必須從起點開始、回到起點)\n### 思路\nTSP問題 狀態壓縮DP [參見](/2017/12/13/UVA-10496-Collecting-Beepers/)  <!--more-->\n我們有興趣的點只有含有電影的商店，題目保證最多12個  \n因此轉換回TSP問題是合理的  \n輸入完圖之後，先計算出任意兩點最短路徑(Floyd Warshall)  \n`dp[x][msk]` 代表以編號x的有片商店為終點，當前狀態為msk，能獲得的最大利益  \n初始條件 `dp[x][(1 << P) - 1] = -編號x殺回起點`  \n轉移時要扣掉油費加上能得到的利潤  \n還有另外一個情況是x後不接點，直接殺回起點  \n### 程式碼\n```cpp\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\ndouble tsp(int x, int msk, vector<vector<double>> &graph, vector<int> &to_idx,\n           vector<double> &val, vector<vector<double>> &dp, int P) {\n    if (dp[x][msk] > -900000000) return dp[x][msk];\n    if (msk == (1 << P) - 1) return dp[x][msk] = -graph[0][to_idx[x]];\n    for (int i = 0; i < P; i++) {\n        if (!(msk & (1 << i))) {\n            dp[x][msk] =\n                max(dp[x][msk],\n                    max(-graph[0][to_idx[x]],\n                        val[i] - graph[to_idx[i]][to_idx[x]] +\n                            tsp(i, msk | (1 << i), graph, to_idx, val, dp, P)));\n        }\n    }\n\n    return dp[x][msk];\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int N, M;\n        cin >> N >> M;\n        N++;\n        vector<vector<double>> graph(N, vector<double>(N, INF));\n        for (int i = 0; i < M; i++) {\n            int a, b;\n            double c;\n            cin >> a >> b >> c;\n            graph[a][b] = min(c, graph[a][b]);\n            graph[b][a] = min(c, graph[b][a]);\n        }\n\n        for (int i = 0; i < N; i++)\n            for (int s = 0; s < N; s++)\n                for (int t = 0; t < N; t++)\n                    graph[s][t] = min(graph[s][t], graph[s][i] + graph[i][t]);\n\n        int P;\n        cin >> P;\n        P++;\n        vector<int> to_idx;\n        vector<double> val;\n        to_idx.push_back(0);\n        val.push_back(0);\n        for (int i = 1; i < P; i++) {\n            int a;\n            double b;\n            cin >> a >> b;\n            to_idx.push_back(a);\n            val.push_back(b);\n        }\n        vector<vector<double>> dp(P, vector<double>(1 << P, -INF));\n        double ans = tsp(0, 1, graph, to_idx, val, dp, P);\n        ans > 1E-9 ? cout << fixed << setprecision(2) << \"Daniel can save $\"\n                          << ans << endl\n                   : cout << \"Don't leave the house\" << endl;\n    }\n}\n\n```\n","tags":["DP"]},{"title":"[UVA] 10496 - Collecting Beepers","url":"/2017/12/13/UVA-10496-Collecting-Beepers/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1437\n### 題意\n給定一個起點  \n再給一坨點  \n問從起點經過所有點回到起點的最短距離  \n只能上下左右走，不能斜的走  \n### 思路\nTSP問題 狀壓DP  <!--more-->\n用一個mask儲存各點遍歷過的狀態  \n以3點為例 111代表所有點都走過 110代表第0點沒走過其餘都走過…  \n`dp[x][msk]` 代表以x為終點，當前狀態為msk，最短纜線總和的值  \n`dp[x][(1 << N - 1)]` (`dp[x][全部都是一]`) 答案為x回到起點的距離  \n 以x為終點，且所有點都已經走過，這種情況直接殺回起點，值設為x回到起點的距離  \n每詢問一次dp[x][msk]，枚舉所有能接在x後的點k(dp[k][msk | 1 << k])  \n滿足`msk & (1 << k) == false` (確保k沒有被走過)  \n最後`dp[x][msk]`就會是所有`dp[k][(msk | 1 << k)]`中最小的\n答案最後存在`dp[0][1]`  \n最後枚舉所有終點，找出最小的方法，並列印答案  \n複雜度$O(N^2 \\times 2^N)$\n\n### 程式碼\n```cpp\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\ninline int dist(pair<int, int> a, pair<int, int> b) {\n    return abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint tsp(int x, int msk, vector<vector<int>>& dp, vector<pair<int, int>>& vp) {\n    if (dp[x][msk] != INF) return dp[x][msk];\n    if (msk == (1 << vp.size()) - 1) return dist(vp[0], vp[x]);\n    for (int i = 0; i < vp.size(); i++) {\n        if (i != x && !((1 << i) & msk)) {\n            dp[x][msk] = min(dp[x][msk], dist(vp[x], vp[i]) +\n                                             tsp(i, msk | (1 << i), dp, vp));\n        }\n    }\n    return dp[x][msk];\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int xs, ys, t1, t2, n;\n        vector<pair<int, int>> vp;\n        cin >> xs >> ys >> t1 >> t2;\n        vp.push_back(make_pair(t1, t2));\n        cin >> n;\n        for (int i = 0; i < n; i++) {\n            cin >> t1 >> t2;\n            vp.push_back(make_pair(t1, t2));\n        }\n        n += 1;\n        vector<vector<int>> dp(n, vector<int>(1 << n, INF));\n        cout << \"The shortest path has length \" << tsp(0, 1, dp, vp) << endl;\n    }\n}\n\n```\n","tags":["DP"]},{"title":"[UVA] 216 - Getting in Line","url":"/2017/12/11/UVA-216-Getting-in-Line/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=152\n### 題意\n給定一張圖，求最短、一條線連接所有的點   \n(每個點只能接兩條邊、非最小生成樹)  \n注意距離要+16(纜線從地底到地上的距離)  \n### 思路\nTSP問題  狀壓DP<!--more-->   \n用一個mask儲存各點遍歷過的狀態\n以3點為例 111代表所有點都走過  110代表第0點沒走過其餘都走過...\n`dp[x][msk]` 代表以x為終點，當前狀態為msk，最短纜線總和的值  \n`dp[x][(1 << N - 1)]` (`dp[x][全部都是一]`) 答案為0  \n 以x為終點，且所有點都已經走過，這種情況什麼纜線都不用多連，值設為0   \n每詢問一次`dp[x][msk]`，枚舉所有能接在x後的點k(`dp[k][msk | 1 << k]`)  \n滿足`msk & (1 << k) == false` (確保k沒有被走過)\n最後`dp[x][msk]`就會是所有`dp[k][(msk | 1 << k)]`中最小的  \n過程中順便紀錄每個點的下個點是什麼，方便最後列印答案  \n最後枚舉所有終點，找出最小的方法，並列印答案  \n複雜度 $O(N^2 \\times 2^N)$\n### 程式碼\n```cpp\n#include <cmath>\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\ninline double dis(pair<int, int> a, pair<int, int> b) {\n    return sqrt((a.first - b.first) * (a.first - b.first) +\n                (a.second - b.second) * (a.second - b.second)) +\n           16;\n}\n\ndouble magic(int x, int msk, vector<vector<double>> &dp,\n             vector<pair<int, int>> &vp, vector<vector<int>> &from) {\n    if (msk == (1 << vp.size()) - 1) return dp[x][msk] = 0;\n    if (dp[x][msk] != INF) return dp[x][msk];\n    double Min = INF;\n    int min_to;\n    for (int k = 0; k < vp.size(); k++) {\n        if (k != x && !(msk & (1 << k))) {\n            double tmp =\n                magic(k, (1 << k) | msk, dp, vp, from) + dis(vp[k], vp[x]);\n            if (Min > tmp) {\n                Min = tmp;\n                min_to = k;\n            }\n        }\n    }\n    from[x][msk] = min_to;\n    return dp[x][msk] = Min;\n}\n\nint main() {\n    int N, cnt = 1;\n    while (cin >> N, N) {\n        vector<pair<int, int>> vp;\n        int t1, t2;\n        for (int i = 0; i < N; i++) {\n            cin >> t1 >> t2;\n            vp.push_back(make_pair(t1, t2));\n        }\n        vector<vector<double>> dp(N, vector<double>(1 << N, INF));\n        vector<vector<int>> from(N, vector<int>(1 << N, INF));\n\n        for (int i = 0; i < N; i++) {\n            dp[i][(1 << N) - 1] = 0;\n        }\n\n        int min_end;\n        double Min = INF;\n        for (int i = 0; i < N; i++) {\n            double tmp = magic(i, 1 << i, dp, vp, from);\n            if (Min > tmp) {\n                Min = tmp;\n                min_end = i;\n            }\n        }\n\n        puts(\"**********************************************************\");\n        printf(\"Network #%d\\n\", cnt++);\n        int msk = 1 << min_end;\n        int cur = min_end, lst = min_end;\n        for (int i = 0; i < N; i++) {\n            if (cur != lst)\n                printf(\n                    \"Cable requirement to connect (%d,%d) to (%d,%d) is %.2lf \"\n                    \"feet.\\n\",\n                    vp[lst].first, vp[lst].second, vp[cur].first,\n                    vp[cur].second, dis(vp[cur], vp[lst]));\n            lst = cur;\n            msk |= (1 << cur);\n            cur = from[cur][msk];\n        }\n        printf(\"Number of feet of cable required is %.2lf.\\n\",\n               dp[min_end][(1 << min_end)]);\n    }\n}\n\n```\n","tags":["DP"]},{"title":"[UVA] 11517 - Exact Change","url":"/2017/12/11/UVA-11517-Exact-Change/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2512\n### 題意\n給定一個價格P，給定n種硬幣  \n問用湊出>=P且最接近P的硬幣數和付出的總價  \n若付出的總價相同則硬幣數量越小越好  \n每種硬幣只能用一次\n### 思路\nDP 類似01背包<!--more-->  \n要先選個背包大小，直接輸入時將背包大小累加直到超過P  \n`dp[j]` 代表價錢為j時的最小方法數  \n轉移式 `dp[j] = min(dp[j - coin[i]] + 1, dp[j]);`  (要確認dp[j - coin[i]]是否存在)  \n最後從P開始找最小價格且達的到的結果  \n複雜度 $O(P \\times N)$之類的\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int N, p, tmp, packsize = 0;\n        vector<int> coin;\n        cin >> p >> N;\n        for (int i = 0; i < N; i++) {\n            cin >> tmp;\n            coin.push_back(tmp);\n            if (packsize < p) packsize += tmp;\n        }\n        vector<int> dp(packsize + 1);\n        dp[0] = 1;\n        for (int i = 0; i < N; i++) {\n            for (int j = packsize; j >= coin[i]; j--) {\n                if (dp[j - coin[i]]) {\n                    if (dp[j]) {\n                        dp[j] = min(dp[j - coin[i]] + 1, dp[j]);\n                    } else {\n                        dp[j] = dp[j - coin[i]] + 1;\n                    }\n                }\n            }\n        }\n        for (int i = p; i <= packsize; i++) {\n            if (dp[i]) {\n                cout << i << ' ' << dp[i] - 1 << endl;\n                break;\n            }\n        }\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 10306 - e-Coins","url":"/2017/12/11/UVA-10306-e-Coins/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1247\n### 題意\n給定m個硬幣，每種硬幣有兩個值conventional value和InfoTechnological value  \n求使用最少硬幣，且滿足 $S = \\sqrt{C^2+I^2}$的硬幣數量\n其中C代表選擇的所有硬幣的conventional value總和  \nI代表代表選擇的所有硬幣的value和InfoTechnological value總和  \n硬幣不限次數\n### 思路\n二維DP 無限背包<!--more-->  \n`DP[J][K]`代表要達成conventional value == J且InfoTechnological value == K的最少方法數\n轉移`dp[j][k] = min(dp[j - coins[i].first][k - coins[i].second] + 1,dp[j][k]);`  \ni代表使用前i個硬幣  \n另外要判斷一下有沒有方法可以達成`dp[j - coins[i].first][k - coins[i].second]`可以才轉移  \n最後跑一圈For找出答案在哪裡  \n複雜度 $O(m \\times S^2)$\n### 程式碼\n```cpp\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int m, s;\n        cin >> m >> s;\n        vector<pair<int, int>> coins;\n        for (int i = 0; i < m; i++) {\n            int t1, t2;\n            cin >> t1 >> t2;\n            coins.push_back(make_pair(t1, t2));\n        }\n        vector<vector<int>> dp(s + 1, vector<int>(s + 1));\n        dp[0][0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = coins[i].first; j <= s; j++) {\n                for (int k = coins[i].second; k <= s; k++) {\n                    if (dp[j - coins[i].first][k - coins[i].second]) {\n                        if (dp[j][k]) {\n                            dp[j][k] = min(\n                                dp[j - coins[i].first][k - coins[i].second] + 1,\n                                dp[j][k]);\n                        } else {\n                            dp[j][k] =\n                                dp[j - coins[i].first][k - coins[i].second] + 1;\n                        }\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        for (int i = 0; i <= s; i++) {\n            int tar = sqrt(s * s - i * i);\n            if (tar * tar + i * i == s * s) {\n                if (dp[i][tar]) ans = min(ans, dp[i][tar] - 1);\n            }\n        }\n        ans == INF ? cout << \"not possible\" << endl : cout << ans << endl;\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 357 - Let Me Count The Ways","url":"/2017/12/07/UVA-357-Let-Me-Count-The-Ways/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=293\n### 題意\n有 1、5、10、25、50 分的硬幣  \n求組合出n元有幾個方法  \n### 思路\nDP `dp[j]` 存組成j元的方法數  `coins[i]`硬幣種類\n`dp[j] += dp[j - coins[i]];`\n注意 long long\npython 又會TLE  QAQ\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    vector<int> coins = {1, 5, 10, 25, 50};\n    int n;\n    while (cin >> n) {\n        vector<long long> dp(n + 1);\n        dp[0] = 1;\n        for (int i = 0; i < coins.size(); i++) {\n            for (int j = coins[i]; j <= n; j++) {\n                dp[j] += dp[j - coins[i]];\n            }\n        }\n        if (dp[n] == 1) {\n            cout << \"There is only 1 way to produce \" << n << \" cents change.\"\n                 << endl;\n        } else {\n            cout << \"There are \" << dp[n] << \" ways to produce \" << n\n                 << \" cents change.\" << endl;\n        }\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 11566 - Let's Yum Cha!","url":"/2017/12/07/UVA-11566-Let-s-Yum-Cha/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2613\n### 題意\n中文題目 http://unfortunatedog.blogspot.tw/2013/07/11566-lets-yum-cha_23.html  \n佛心網站╭(⊙Д⊙)╯佛心網站╰(⊙Д⊙)╮  \n### 思路\n先計算扣掉茶費、手續費後的預算  \n每個東西可以用兩次，所以每樣東西都塞兩個到vector裡  \n`dp[j][k]`代表選了j盤點心，總價格為k元的數量  \n枚舉點心種類、選擇數量、價格總和  \n轉移式\n`dp[j][k] = max(dp[j - 1][k - price[i]] + favor[i], dp[j - 1][k], dp[j][k])`\n最後跑for看選$2 \\times (N+1)$、且在預算內最大的方法數  \n注意 除1.1會有浮點數誤差  \n注意 茶費的部分也要算服務費  \n<!--more-->\n### 程式碼\n```cpp\n#include <iomanip>\n#include <iostream>\n#include <vector>\n#define INF 1000000000\nusing namespace std;\n\nint main() {\n    int N, X, T, K, V;\n    while (cin >> N >> X >> T >> K, N | X | T | K) {\n        vector<int> favor;\n        vector<int> price;\n        N += 1;\n        V = (X * N) / 1.1 + 1e-9;\n        V -= T * N;\n        // cout << \"V:\" << V << endl;\n        // X = (X - T * N);\n        for (int i = 0; i < K; i++) {\n            int tmp, Sum = 0;\n            vector<int> tmpv(N);\n            cin >> tmp;\n            price.push_back(tmp);\n            price.push_back(tmp);\n            for (int j = 0; j < N; j++) {\n                cin >> tmp;\n                Sum += tmp;\n            }\n            favor.push_back(Sum);\n            favor.push_back(Sum);\n        }\n        vector<vector<int>> dp(2 * N + 1, vector<int>(V + 1));\n        for (int i = 0; i < K * 2; i++) {\n            for (int j = 2 * N; j > 0; j--) {\n                for (int k = V; k >= price[i]; k--) {\n                    dp[j][k] = max(dp[j - 1][k - price[i]] + favor[i],\n                                   max(dp[j - 1][k], dp[j][k]));\n                }\n            }\n        }\n        int Max = -INF;\n        for (int i = 0; i <= 2 * N; i++) {\n            Max = max(dp[i][V], Max);\n        }\n        cout << setprecision(2) << fixed << (double)Max / N << endl;\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 11789 - Texas Hold'em Poker Solitaire","url":"/2017/12/07/UVA-11789-Texas-Hold-em-Poker-Solitaire/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=nlinejudge&category=117&page=show_problem&problem=2889\n### 題意\n給一個7*7的矩陣  \n每條直線，橫線、對角線的7張中，尋找能產生最大手牌的5張  \n求最大的線是哪一條，和那5張牌是什麼  \n### 思路\n暴力枚舉所有直線，橫線、對角線  \n在暴力枚舉7張中不要的兩張  \n輸出最大的，注意輸出的順序不要亂掉  \n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass card {  //卡片類別\n   private:\n    int num;     //數字\n    char suit;   //花色\n    string raw;  //原始字串\n\n   public:\n    card(string s) {      //建構子\n        raw = s;          //複製原始字串\n        suit = s[1];      //花色\n        if (s[0] == 'T')  //判斷數字\n            num = 10;\n        else if (s[0] == 'J')\n            num = 11;\n        else if (s[0] == 'Q')\n            num = 12;\n        else if (s[0] == 'K')\n            num = 13;\n        else if (s[0] == 'A')\n            num = 14;\n        else\n            num = s[0] - '0';\n    }\n    bool operator>(const card& other) {  //重載 > 運算\n        if (num == other.num) {\n            return suit > other.suit;  //若數字一樣比較花色\n        } else {\n            return num > other.num;  //比較數字\n        }\n    }\n    bool operator!=(const card& other) {  //重載 != 運算\n        return num != other.num || suit != other.suit;\n    }\n    friend ostream& operator<<(ostream& os, const card& cd);\n    friend class hand;\n};\n\nostream& operator<<(ostream& os, const vector<card>& v) {\n    for (auto i : v) os << i << ' ';\n    return os;\n}\n\nclass hand {  //手牌類別\n   private:\n    vector<vector<card>> h;  //手牌\n    vector<card> raw;\n    bool flush, straight;  //同花、順子\n    int win;               //牌種類\n\n   public:\n    hand() { win = -1; };  //預設-1\n    hand(vector<card> v) {\n        raw = v;\n        flush = straight = true;  //當作都是同花順\n        //由大到小排序手牌\n        sort(begin(v), end(v), [](card& a, card& b) { return a > b; });\n        //判斷A要當作1的特例\n        if (v[0].num == 14 && v[1].num == 5 && v[2].num == 4 && v[3].num == 3 &&\n            v[4].num == 2) {\n            v[0].num = 1;\n            sort(begin(v), end(v), [](card& a, card& b) { return a > b; });\n        }\n        int last_suit = v[0].suit,\n            last_num = v[0].num + 1;  //紀錄上一個花色、數字\n        for (auto& i : v) {\n            //花色與上次不同非同花\n            if (last_suit != i.suit) flush = false;\n            //數字非上次的-1 非順子\n            if (last_num != i.num + 1) straight = false;\n            last_suit = i.suit, last_num = i.num;\n            bool pushed = false;\n            //把數字相同的疊在同一推\n            for (auto& j : h) {\n                if (i.num == j[0].num) {\n                    j.push_back(i);\n                    pushed = true;\n                    break;\n                }\n            }\n            //跟原本的都不一樣做一個新的堆\n            if (!pushed) {\n                vector<card> tmp;\n                tmp.push_back(i);\n                h.push_back(tmp);\n            }\n        }\n        //用每堆的張數stable_sort 保持原先排大到小的順序\n        stable_sort(begin(h), end(h), [](vector<card> a, vector<card> b) {\n            return a.size() > b.size();\n        });\n        //尋找最大排型\n        win = 0;                                            //非洲人牌運\n        if (h[0].size() == 2) win = 1;                      //對子\n        if (h[0].size() == 2 && h[1].size() == 2) win = 2;  //兩對\n        if (h[0].size() == 3) win = 3;                      //三條\n        if (straight) win = 4;                              //順子\n        if (flush) win = 5;                                 //同花\n        if (h[0].size() == 3 && h[1].size() == 2) win = 6;  //葫蘆\n        if (h[0].size() == 4) win = 7;                      //鐵支\n        if (flush && straight) win = 8;                     //牛B牌\n    }\n    int cmp(const hand& other) {  //判斷兩手牌大小 不考慮花色 相同回傳2\n        if (win == other.win) {\n            for (int i = 0; i < h.size(); i++) {\n                for (int j = 0; j < h[i].size(); j++) {\n                    if (h[i][j].num != other.h[i][j].num)\n                        return h[i][j].num > other.h[i][j].num;\n                }\n            }\n            return 2;\n        } else {\n            return win > other.win;\n        }\n    }\n    bool operator>(const hand& other) { return win > other.win; }\n    friend ostream& operator<<(ostream& os, const hand& hd);\n};\n\n//定義cout<<card\nostream& operator<<(ostream& os, const card& cd) {\n    os << cd.raw;\n    return os;\n}\n\n//定義cout<<hand\nostream& operator<<(ostream& os, const hand& hd) {\n    const string win_type[9] = {\n        \"High Cards\",      \"One Pair\",       \"Two Pair\",\n        \"Three of a Kind\", \"Straight\",       \"Flush\",\n        \"Full House\",      \"Four of a Kind\", \"Straight Flush\"};\n    os << hd.raw << ' ';\n    os << win_type[hd.win];\n    return os;\n}\n\nhand bestof7(vector<card> cards) {\n    hand best;\n    for (int i = 6; i > 0; i--) {  //枚舉兩張不要的\n        for (int j = i - 1; j >= 0; j--) {\n            vector<card> tmp;\n            for (int k = 0; k < 7; k++) {  //製作一個5張的手牌\n                if (k != i && k != j) tmp.push_back(cards[k]);\n            }\n            hand hd(tmp);\n            if (hd.cmp(best) == 1) best = hd;  //儲存較大的手牌\n        }\n    }\n    return best;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        vector<vector<card>> v(7);\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                string tmp;\n                cin >> tmp;\n                v[i].push_back(card(tmp));\n            }\n        }\n        hand best;\n        vector<card> best1, best2;\n        for (int i = 0; i < 7; i++) {\n            hand best_this = bestof7(v[i]);\n            if (best_this.cmp(best) == 1) {\n                best = best_this;\n                best1 = v[i];\n            }\n        }\n        for (int i = 0; i < 7; i++) {\n            vector<card> tmp;\n            for (int j = 0; j < 7; j++) tmp.push_back(v[j][i]);\n            hand best_this = bestof7(tmp);\n            if (best_this.cmp(best) == 1) {\n                best = best_this;\n                best1 = tmp;\n            }\n        }\n        vector<card> tmp;\n        for (int j = 0; j < 7; j++) tmp.push_back(v[j][j]);\n        hand best_this = bestof7(tmp);\n        if (best_this.cmp(best) == 1) {\n            best = best_this;\n            best1 = tmp;\n        }\n        tmp.clear();\n        for (int j = 0; j < 7; j++) tmp.push_back(v[6 - j][j]);\n        best_this = bestof7(tmp);\n        if (best_this.cmp(best) == 1) {\n            best = best_this;\n            best1 = tmp;\n        }\n        cout << best1 << ' ' << best << endl;\n    }\n}\n```\n","tags":["Texas"]},{"title":"[UVA] 131 - The Psychic Poker Player","url":"/2017/12/07/UVA-131-The-Psychic-Poker-Player/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=67\n### 題意\n給定5張手牌，5張牌庫牌  \n可以棄掉自己手上n張牌，從牌庫頂端拿n張  \n求最大的  \n### 思路\n狀態壓縮，暴力解  \n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass card {  //卡片類別\n   private:\n    int num;     //數字\n    char suit;   //花色\n    string raw;  //原始字串\n\n   public:\n    card(string s) {      //建構子\n        raw = s;          //複製原始字串\n        suit = s[1];      //花色\n        if (s[0] == 'T')  //判斷數字\n            num = 10;\n        else if (s[0] == 'J')\n            num = 11;\n        else if (s[0] == 'Q')\n            num = 12;\n        else if (s[0] == 'K')\n            num = 13;\n        else if (s[0] == 'A')\n            num = 14;\n        else\n            num = s[0] - '0';\n    }\n    bool operator>(const card& other) {  //重載 > 運算\n        if (num == other.num) {\n            return suit > other.suit;  //若數字一樣比較花色\n        } else {\n            return num > other.num;  //比較數字\n        }\n    }\n    bool operator!=(const card& other) {  //重載 != 運算\n        return num != other.num || suit != other.suit;\n    }\n    friend ostream& operator<<(ostream& os, const card& cd);\n    friend class hand;\n};\n\nostream& operator<<(ostream& os, const vector<card>& v) {\n    for (auto i : v) os << i << ' ';\n    return os;\n}\nclass hand {  //手牌類別\n   private:\n    vector<vector<card>> h;  //手牌\n    bool flush, straight;    //同花、順子\n    int win;                 //牌種類\n\n   public:\n    hand() { win = -1; };  //預設-1\n    hand(vector<card> v) {\n        flush = straight = true;  //當作都是同花順\n        //由大到小排序手牌\n        sort(begin(v), end(v), [](card& a, card& b) { return a > b; });\n        //判斷A要當作1的特例\n        if (v[0].num == 14 && v[1].num == 5 && v[2].num == 4 && v[3].num == 3 &&\n            v[4].num == 2) {\n            v[0].num = 1;\n            sort(begin(v), end(v), [](card& a, card& b) { return a > b; });\n        }\n        int last_suit = v[0].suit,\n            last_num = v[0].num + 1;  //紀錄上一個花色、數字\n        for (auto& i : v) {\n            //花色與上次不同非同花\n            if (last_suit != i.suit) flush = false;\n            //數字非上次的-1 非順子\n            if (last_num != i.num + 1) straight = false;\n            last_suit = i.suit, last_num = i.num;\n            bool pushed = false;\n            //把數字相同的疊在同一推\n            for (auto& j : h) {\n                if (i.num == j[0].num) {\n                    j.push_back(i);\n                    pushed = true;\n                    break;\n                }\n            }\n            //跟原本的都不一樣做一個新的堆\n            if (!pushed) {\n                vector<card> tmp;\n                tmp.push_back(i);\n                h.push_back(tmp);\n            }\n        }\n        //用每堆的張數stable_sort 保持原先排大到小的順序\n        stable_sort(begin(h), end(h), [](vector<card> a, vector<card> b) {\n            return a.size() > b.size();\n        });\n        //尋找最大排型\n        win = 0;                                            //非洲人牌運\n        if (h[0].size() == 2) win = 1;                      //對子\n        if (h[0].size() == 2 && h[1].size() == 2) win = 2;  //兩對\n        if (h[0].size() == 3) win = 3;                      //三條\n        if (straight) win = 4;                              //順子\n        if (flush) win = 5;                                 //同花\n        if (h[0].size() == 3 && h[1].size() == 2) win = 6;  //葫蘆\n        if (h[0].size() == 4) win = 7;                      //鐵支\n        if (flush && straight) win = 8;                     //牛B牌\n    }\n    int cmp(const hand& other) {  //判斷兩手牌大小 不考慮花色 相同回傳2\n        if (win == other.win) {\n            for (int i = 0; i < h.size(); i++) {\n                for (int j = 0; j < h[i].size(); j++) {\n                    if (h[i][j].num != other.h[i][j].num)\n                        return h[i][j].num > other.h[i][j].num;\n                }\n            }\n            return 2;\n        } else {\n            return win > other.win;\n        }\n    }\n    bool operator>(const hand& other) {  //判斷兩手牌大小 考慮花色\n        if (win == other.win) {\n            for (int i = 0; i < h.size(); i++) {\n                for (int j = 0; j < h[i].size(); j++) {\n                    if (h[i][j] != other.h[i][j])\n                        return h[i][j] > other.h[i][j];\n                }\n            }\n        } else {\n            return win > other.win;\n        }\n    }\n    friend ostream& operator<<(ostream& os, const hand& hd);\n};\n\n//定義cout<<card\nostream& operator<<(ostream& os, const card& cd) {\n    os << cd.raw;\n    return os;\n}\n\n//定義cout<<hand\nostream& operator<<(ostream& os, const hand& hd) {\n    const string win_type[9] = {\n        \"highest-card\",    \"one-pair\",       \"two-pairs\",\n        \"three-of-a-kind\", \"straight\",       \"flush\",\n        \"full-house\",      \"four-of-a-kind\", \"straight-flush\"};\n    os << win_type[hd.win];\n    return os;\n}\n\nint main() {\n    while (1) {\n        vector<card> inhand, deck;\n        string s;\n        for (int i = 0; i < 5; i++) {\n            if (!(cin >> s)) return 0;\n            inhand.push_back(card(s));\n        }\n\n        for (int i = 0; i < 5; i++) {\n            cin >> s;\n            deck.push_back(card(s));\n        }\n\n        hand maxhand;\n        for (int i = 0; i < (1 << 5); i++) {\n            vector<card> tmp;\n            for (int j = 0; j < 5; j++) {\n                if ((1 << j) & i) tmp.push_back(inhand[j]);\n            }\n            for (int j = 0; tmp.size() < 5; j++) {\n                tmp.push_back(deck[j]);\n            }\n            hand h(tmp);\n            if (h > maxhand) maxhand = h;\n        }\n        cout << \"Hand: \" << inhand << \"Deck: \" << deck\n             << \"Best hand: \" << maxhand << endl;\n    }\n}\n\n```\n","tags":["Texas"]},{"title":"[UVA] 10315 - Poker Hands","url":"/2017/12/07/UVA-10315-Poker-Hands/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1256\n### 題意\n給兩個人的手牌，問誰的比較大  \n### 思路\n剛好做了個跟德州撲克有關的class  \n只好隨便A幾題UVA  \n<!--more-->\n### 程式碼\n很多跟這題無關的code看看就好\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass card {  //卡片類別\n   private:\n    int num;     //數字\n    char suit;   //花色\n    string raw;  //原始字串\n\n   public:\n    card(string s) {      //建構子\n        raw = s;          //複製原始字串\n        suit = s[1];      //花色\n        if (s[0] == 'T')  //判斷數字\n            num = 10;\n        else if (s[0] == 'J')\n            num = 11;\n        else if (s[0] == 'Q')\n            num = 12;\n        else if (s[0] == 'K')\n            num = 13;\n        else if (s[0] == 'A')\n            num = 14;\n        else\n            num = s[0] - '0';\n    }\n    bool operator>(const card& other) {  //重載 > 運算\n        if (num == other.num) {\n            return suit > other.suit;  //若數字一樣比較花色\n        } else {\n            return num > other.num;  //比較數字\n        }\n    }\n    bool operator!=(const card& other) {  //重載 != 運算\n        return num != other.num || suit != other.suit;\n    }\n    friend ostream& operator<<(ostream& os, const card& cd);\n    friend class hand;\n};\n\nostream& operator<<(ostream& os, const vector<card>& v) {\n    for (auto i : v) os << i << ' ';\n    return os;\n}\n\nclass hand {  //手牌類別\n   private:\n    vector<vector<card>> h;  //手牌\n    bool flush, straight;    //同花、順子\n    int win;                 //牌種類\n\n   public:\n    hand() { win = -1; };  //預設-1\n    hand(vector<card> v) {\n        flush = straight = true;  //當作都是同花順\n        //由大到小排序手牌\n        sort(begin(v), end(v), [](card& a, card& b) { return a > b; });\n        //判斷A要當作1的特例\n        if (v[0].num == 14 && v[1].num == 5 && v[2].num == 4 && v[3].num == 3 &&\n            v[4].num == 2) {\n            v[0].num = 1;\n            sort(begin(v), end(v), [](card& a, card& b) { return a > b; });\n        }\n        int last_suit = v[0].suit,\n            last_num = v[0].num + 1;  //紀錄上一個花色、數字\n        for (auto& i : v) {\n            //花色與上次不同非同花\n            if (last_suit != i.suit) flush = false;\n            //數字非上次的-1 非順子\n            if (last_num != i.num + 1) straight = false;\n            last_suit = i.suit, last_num = i.num;\n            bool pushed = false;\n            //把數字相同的疊在同一推\n            for (auto& j : h) {\n                if (i.num == j[0].num) {\n                    j.push_back(i);\n                    pushed = true;\n                    break;\n                }\n            }\n            //跟原本的都不一樣做一個新的堆\n            if (!pushed) {\n                vector<card> tmp;\n                tmp.push_back(i);\n                h.push_back(tmp);\n            }\n        }\n        //用每堆的張數stable_sort 保持原先排大到小的順序\n        stable_sort(begin(h), end(h), [](vector<card> a, vector<card> b) {\n            return a.size() > b.size();\n        });\n        //尋找最大排型\n        win = 0;                                            //非洲人牌運\n        if (h[0].size() == 2) win = 1;                      //對子\n        if (h[0].size() == 2 && h[1].size() == 2) win = 2;  //兩對\n        if (h[0].size() == 3) win = 3;                      //三條\n        if (straight) win = 4;                              //順子\n        if (flush) win = 5;                                 //同花\n        if (h[0].size() == 3 && h[1].size() == 2) win = 6;  //葫蘆\n        if (h[0].size() == 4) win = 7;                      //鐵支\n        if (flush && straight) win = 8;                     //牛B牌\n    }\n    int cmp(const hand& other) {  //判斷兩手牌大小 不考慮花色 相同回傳2\n        if (win == other.win) {\n            for (int i = 0; i < h.size(); i++) {\n                for (int j = 0; j < h[i].size(); j++) {\n                    if (h[i][j].num != other.h[i][j].num)\n                        return h[i][j].num > other.h[i][j].num;\n                }\n            }\n            return 2;\n        } else {\n            return win > other.win;\n        }\n    }\n    bool operator>(const hand& other) {  //判斷兩手牌大小 考慮花色\n        if (win == other.win) {\n            for (int i = 0; i < h.size(); i++) {\n                for (int j = 0; j < h[i].size(); j++) {\n                    if (h[i][j] != other.h[i][j])\n                        return h[i][j] > other.h[i][j];\n                }\n            }\n        } else {\n            return win > other.win;\n        }\n    }\n    friend ostream& operator<<(ostream& os, const hand& hd);\n};\n\n//定義cout<<card\nostream& operator<<(ostream& os, const card& cd) {\n    os << cd.raw;\n    return os;\n}\n\n//定義cout<<hand\nostream& operator<<(ostream& os, const hand& hd) {\n    const string win_type[9] = {\"High Card\",  \"Pair\",     \"Two Pairs\",\n                                \"Trips\",      \"Straight\", \"Flush\",\n                                \"Full House\", \"Quads\",    \"Straight Flush\"};\n    for (auto& i : hd.h) {\n        for (auto& j : i) {\n            os << j << ' ';\n        }\n    }\n    os << win_type[hd.win];\n    return os;\n}\n\nint main() {\n    while (1) {\n        vector<card> tmp;\n        string s;\n        for (int i = 0; i < 5; i++) {\n            if (!(cin >> s)) return 0;\n            tmp.push_back(card(s));\n        }\n        hand black(tmp);\n        tmp.clear();\n        for (int i = 0; i < 5; i++) {\n            cin >> s;\n            tmp.push_back(card(s));\n        }\n        hand white(tmp);\n        int cmp = black.cmp(white);\n        if (cmp == 1) {\n            cout << \"Black wins.\" << endl;\n        } else if (cmp == 2) {\n            cout << \"Tie.\" << endl;\n        } else {\n            cout << \"White wins.\" << endl;\n        }\n    }\n}\n```\n","tags":["Texas"]},{"title":"[UVA] 10819 - Trouble of 13-Dots","url":"/2017/12/07/UVA-10819-Trouble-of-13-Dots/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1760\n### 題意\n給一堆商品的喜好程度及價錢  \n求在預算下能夠獲得的最大喜好程度總和  \n滿2000時可以折價200元  \n### 思路\n背包問題的變形  \n直接把預算加上200元  \ndp[i]求**剛好**花i塊錢能獲得的最大喜好程度  \n最後跑一圈for看預算內最大喜好程度如何  \n這個方法可以解決下面那種奇怪的狀況   \n<!--more-->\n### 後紀\n這題神奇的點是網路上很多AC的Code是過不了udebug裡面幾個特殊設計過的測資\n不過顯然UVA的測資也是爛爛的 才能隨便AC  \n```\n輸入\n1900 3\n2000 5\n1950 2\n101 1\n\n1801 3\n2000 3\n1900 1\n101 1\n\n1801 3\n2001 3\n1900 1\n101 1\n\n輸出\n3\n2\n3\n```\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int m, n;\n    while (cin >> m >> n) {\n        int p, v;\n        vector<int> pv(n), vv(n);\n        for (int i = 0; i < n; i++) cin >> pv[i] >> vv[i];\n        vector<int> dp(m + 205);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = m + 200; j >= pv[i]; j--) {\n                if (!dp[j - pv[i]] && j != pv[i]) continue;  //有點重要\n                dp[j] = max(dp[j], dp[j - pv[i]] + vv[i]);\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i <= m + 200; i++) {\n            if ((i > 2000 && i <= m + 200) || i <= m) ans = max(ans, dp[i]);\n        }\n        cout << ans << endl;\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 10616 Divisible Group Sums","url":"/2017/12/05/UVA-10616-Divisible-Group-Sums/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1557\n### 題意\n給一拖拉庫數字  \n問從一拖拉庫數字取M個總和可以被D整除的有幾個  \n### 思路\n將一拖拉庫數字每個都%D\n全部總和最大是$N \\times D$，以這個當背包大小  \n枚舉所有數字、取的數量、總和  \n`dp[i][j]`  代表取j個總和是i  \n初始條件`dp[0][0]`  \n轉移`dp[v][m] += dp[v - data2[n]][m - 1]`  \n(取m個總和是v數量 += 取m-1個總和是v - 自己這個數字)  \n<!--more-->\n注意對負數取%\n注意long long\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int t = 0;\n    while (++t) {\n        int N, Q;\n        cin >> N >> Q;\n        if ((N | Q) == 0) break;\n        vector<int> data(N), data2(N);\n        for (int i = 0; i < N; i++) cin >> data[i];\n        cout << \"SET \" << t << \":\" << endl;\n        for (int q = 1; q <= Q; q++) {\n            int D, M;\n            int V;\n            cin >> D >> M;\n            for (int i = 0; i < N; i++) {\n                if (data[i] >= 0) {\n                    data2[i] = (data[i] + D) % D;\n                } else {\n                    data2[i] = D - (-data[i] % D);\n                }\n            }\n            V = D * N;\n            vector<vector<long long>> dp(V + 1, vector<long long>(M + 1));\n            dp[0][0] = 1;\n            for (int n = 0; n < N; n++) {                  //枚舉所有數字\n                for (int m = M; m > 0; m--) {              //枚舉取的個數\n                    for (int v = V; v >= data2[n]; v--) {  //枚舉背包Size\n                        dp[v][m] += dp[v - data2[n]][m - 1];\n                    }\n                }\n            }\n            long long int ans = 0;\n            for (int i = 0; i <= V; i += D) ans += dp[i][M];\n            cout << \"QUERY \" << q << \": \" << ans << endl;\n        }\n    }\n}\n\n```\n","tags":["DP"]},{"title":"[UVA] 11790 - Murcia's Skyline","url":"/2017/12/05/UVA-11790-Murcia-s-Skyline/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2890\n### 題意\n給定一列建築物\n每建築物有高和寬\n求高度遞增且寬度最寬的\n和高度遞減且寬度最寬的\n### 思路\n典型的LIS $O(n^2)$作法\n沒辦法二分搜優化\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int T;\n    cin >> T;\n    for (int t = 1; t <= T; t++) {\n        int N;\n        cin >> N;\n        vector<int> h(N), w(N);\n        for (int i = 0; i < N; i++) cin >> h[i];\n        for (int i = 0; i < N; i++) cin >> w[i];\n\n        vector<int> lis(N), lds(N);\n        for (int i = 0; i < N; i++) lis[i] = lds[i] = w[i];\n\n        for (int i = 0; i < N; i++)\n            for (int j = i + 1; j < N; j++)\n                if (h[i] < h[j]) lis[j] = max(lis[j], lis[i] + w[j]);\n\n        for (int i = 0; i < N; i++)\n            for (int j = i + 1; j < N; j++)\n                if (h[i] > h[j]) lds[j] = max(lds[j], lds[i] + w[j]);\n\n        int mlis = *max_element(lis.begin(), lis.end()),\n            mlds = *max_element(lds.begin(), lds.end());\n\n        if (mlis >= mlds)\n            cout << \"Case \" << t << \". Increasing (\" << mlis\n                 << \"). Decreasing (\" << mlds << \").\" << endl;\n        else\n            cout << \"Case \" << t << \". Decreasing (\" << mlds\n                 << \"). Increasing (\" << mlis << \").\" << endl;\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 11456 - Trainsorting","url":"/2017/11/29/UVA-11456-Trainsorting/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2451\n### 題意\nErin想要造一台火車，越重的一定要在越前面\n有一串車廂進站，Erin的操作只有三種\n1. 加到現有火車的最前面\n2. 加到現有火車的最後面\n3. 把該車廂引爆並消失在虛無之中\n\n### 思路\nErin一定是選擇某個車廂當作第一個加進火車的  \n假設該車廂編號是$i$  \n選擇i之後就開始往前後延伸  \n往前(越來越重)延伸，相當於求$i$開始到底的LIS  \n往後(越來越輕)延伸，相當於求$i$開始到底的LDS  \n枚舉所有$i$，複雜度$O(n*n*Log(n))$恭喜獲得一個TLE\n<!--more-->\n換個方向想，$nlog(n)$的LIS算法，  \n就是一個點一個點加入可以獲得從起點到該點的LIS大小  \n運用到這題就可以當作枚舉所有點$i$  \n求$i$開始到底的LIS，改成求底到$i$的LDS  \n求$i$開始到底的LDS，改成求底到$i$的LIS  \n每加進去一個點，當時最長火車長度為LDS + LIS - 1(i重複算)  \n最後輸出最大值\n\n抑或是在轉一個圈，直接將原序列前面再加一個反轉的原序列  \n直接在那個序列求LIS  \n### 程式碼\n```python\nimport bisect\n\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        N = int(input())\n        lst = []\n        for n in range(N):\n            lst.append(int(input()))\n        lst = lst[::-1] + lst\n        lis = []\n        for i in lst:\n            if not lis or lis[-1] < i:\n                lis.append(i)\n            else:\n                lis[bisect.bisect_left(lis, i)] = i\n        print(len(lis))\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["DP"]},{"title":"[UVA] 481 - What Goes Up","url":"/2017/11/29/UVA-481-What-Goes-Up/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&category=24&page=show_problem&problem=422\n### 題意\n典型LIS\n### 思路\n標準LIS作法\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(0);\n    int tmp;\n    vector<int> v;\n    while (cin >> tmp) v.push_back(tmp);\n    vector<int> lis, pos(v.size());\n    for (int i = 0; i < v.size(); i++) {\n        if (lis.size() == 0 || v[i] > lis.back()) {\n            lis.push_back(v[i]);\n            pos[i] = lis.size();\n        } else {\n            auto it = lower_bound(begin(lis), end(lis), v[i]);\n            *it = v[i];\n            pos[i] = it - begin(lis) + 1;\n        }\n    }\n    stack<int> ans;\n    int len = lis.size();\n    auto it = pos.end();\n    cout << len << '\\n' << '-' << '\\n';\n    while (len) {\n        while (*(--it) != len)\n            ;\n        ans.push(v[it - pos.begin()]);\n        len--;\n    }\n    while (!ans.empty()) {\n        cout << ans.top() << '\\n';\n        ans.pop();\n    }\n}\n\n```\n","tags":["DP"]},{"title":"[UVA] 11951 - Area","url":"/2017/11/23/UVA-11951-Area/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&category=24&page=show_problem&problem=3102\n### 題意\n找出面積最大，而且價錢總和<=K的子矩形\n如果相同找價錢最小的\n### 思路\n還是[UVA 108](/2017/11/22/UVA-108-Maximum-Sum/)升級版\n因為那堤本來就是用$O(N^3)$的方法做\n所以這題就用相同方法，\n不過在算一維最大連續和的時候要小於K\n(如果大於K就從前面扣掉)\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n    int T;\n    cin >> T;\n    for (int t = 1; t <= T; t++) {\n        int N, M, K;\n        cin >> N >> M >> K;\n        vector<vector<int>> graph(N, vector<int>(M));\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < M; j++) cin >> graph[i][j];\n        int ans1 = 0, ans2 = 0;\n        for (int st = 0; st < N; st++) {\n            vector<int> dp(M);\n            for (int ed = st; ed < N; ed++) {\n                for (int i = 0; i < M; i++) dp[i] += graph[ed][i];\n                int tmp = 0, stc = 0;\n                for (int edc = 0; edc < M; edc++) {\n                    tmp += dp[edc];\n                    while (tmp > K) tmp -= dp[stc++];\n                    int area = (edc - stc + 1) * (ed - st + 1);\n                    if (area > ans1 || (area == ans1 && tmp < ans2)) {\n                        ans1 = area;\n                        ans2 = tmp;\n                    }\n                }\n            }\n        }\n        cout << \"Case #\" << t << \": \" << ans1 << \" \" << ans2 << '\\n';\n    }\n}\n```\n\n附贈會TLE的Python版\n為什麼只有1秒 QAQ\n```python\nimport sys\n\n\ndef main():\n    T = int(sys.stdin.readline())\n    for t in range(T):\n        N, M, K = map(int, sys.stdin.readline().split())\n        graph = []\n        for n in range(N):\n            graph.append(list(map(int, sys.stdin.readline().split())))\n\n        ans1 = 0\n        ans2 = 0\n        for st in range(N):\n            dp = [0] * M\n            for ed in range(st, N):\n                for idx, cell in enumerate(graph[ed]):\n                    dp[idx] += cell\n                stc = 0\n                tmp = 0\n                for edc in range(stc, M):\n                    tmp += dp[edc]\n                    while tmp > K:\n                        tmp -= dp[stc]\n                        stc += 1\n                    area = (edc - stc + 1) * (ed - st + 1)\n                    if area > ans1 or (area == ans1 and tmp < ans2):\n                        ans1 = area\n                        ans2 = tmp\n        sys.stdout.write(\"Case #{}: {} {}\\n\".format(t + 1, ans1, ans2))\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["DP"]},{"title":"[UVA] 10827 - Maximum sum on a torus","url":"/2017/11/22/UVA-10827-Maximum-sum-on-a-torus/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1768\n### 題意\n求最大子矩陣和\n不過整個是個環矩陣\n走到最右回到最左，走到最上回到最下......\n### 思路\n[UVA 108](/2017/11/22/UVA-108-Maximum-Sum/)升級版\n複雜度$O(N^4)$\n<!--more-->\n枚舉列的部分要枚舉一圈回來\n處理一維的時候枚舉所有起點，所以複雜度多乘上一個$N$\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        vector<vector<int>> graph(n, vector<int>(n));\n        vector<int> dp;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++) cin >> graph[i][j];\n        int ans = -INF;\n        for (int st = 0; st < n; st++) {\n            dp.clear();\n            dp.resize(n, 0);\n            for (int ed = st; ed < n + st; ed++) {\n                for (int i = 0; i < n; i++) {\n                    dp[i] = dp[i] + graph[ed % n][i];\n                }\n                for (int j = 0; j < n; j++) {\n                    int tmp = 0;\n                    for (int i = j; i < n + j; i++) {\n                        tmp += dp[i % n];\n                        if (tmp > ans) ans = tmp;\n                        if (tmp < 0) tmp = 0;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 10755 - Garbage Heap","url":"/2017/11/22/UVA-10755-Garbage-Heap/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1696\n### 題意\n求最大子長方體和\n### 思路\n[UVA 108](/2017/11/22/UVA-108-Maximum-Sum/)升級版\n那一題是枚舉邊壓回一維陣列求解\n這一題枚舉面->枚舉列->一維最大連續和\n<!--more-->\n注意`long long`和`Print a blank line between test cases.`\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 0x3f3f3f3f3f3f3f3f\n\nusing namespace std;\n\nlong long int solve2d(vector<vector<long long>> &graph, int b, int c) {\n    vector<long long> dp;\n    long long int ans = -INF;\n    for (int st = 0; st < b; st++) {\n        dp.clear();\n        dp.resize(c, 0);\n        for (int ed = st; ed < b; ed++) {\n            for (int i = 0; i < c; i++) {\n                dp[i] = dp[i] + graph[ed][i];\n            }\n            long long int tmp = 0;\n            for (int i = 0; i < c; i++) {\n                tmp += dp[i];\n                if (tmp > ans) ans = tmp;\n                if (tmp < 0) tmp = 0;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        vector<vector<vector<long long>>> graph(\n            a, vector<vector<long long>>(b, vector<long long>(c)));\n        for (int i = 0; i < a; i++)\n            for (int j = 0; j < b; j++)\n                for (int k = 0; k < c; k++) cin >> graph[i][j][k];\n\n        vector<vector<long long>> dp2;\n        long long int ans = -INF;\n        for (int st = 0; st < a; st++) {\n            dp2.clear();\n            dp2.resize(b, vector<long long>(c));\n            for (int ed = st; ed < a; ed++) {\n                for (int i = 0; i < b; i++) {\n                    for (int j = 0; j < c; j++) {\n                        dp2[i][j] += graph[ed][i][j];\n                    }\n                }\n                ans = max(solve2d(dp2, b, c), ans);\n            }\n        }\n        cout << ans << endl;\n        if (T != 0) cout << endl;\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 108 - Maximum Sum","url":"/2017/11/22/UVA-108-Maximum-Sum/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=44\n### 題意\n求最大子矩陣和\n### 思路\n壓縮回一維最大連續和\n枚舉起始列、結束列 ($O(N^2)$)\n建立一個一維陣列\n儲存當前起始列到結束列的總和<!--more-->\n>ex 如果枚舉到起始列 = 1 結束列 = 4\n>則 dp[x] = graph[1][x] + ... + graph[4][x]\n\n在該陣列求最大一維連續和\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin >> n) {\n        vector<vector<int>> graph(n, vector<int>(n));\n        vector<int> dp;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++) cin >> graph[i][j];\n        int ans = -INF;\n        for (int st = 0; st < n; st++) {\n            dp.clear();\n            dp.resize(n, 0);\n            for (int ed = st; ed < n; ed++) {\n                for (int i = 0; i < n; i++) {\n                    dp[i] = dp[i] + graph[ed][i];\n                }\n                int tmp = 0;\n                for (int i = 0; i < n; i++) {\n                    tmp += dp[i];\n                    if (tmp > ans) ans = tmp;\n                    if (tmp < 0) tmp = 0;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n```\n","tags":["DP"]},{"title":"[UVALive] 7008 - Tactical Multiple Defense System","url":"/2017/11/22/UVALive-7008-Tactical-Multiple-Defense-System/","content":"### 出處\nhttps://icpcarchive.ecs.baylor.edu/index.php?option=onlinejudge&page=show_problem&problem=5020\nhttps://oj.nctu.me/problems/260/\n### 題意\n題目提供一堆飛彈位置\n$r_i t_i s_i$ 代表飛彈在 $(r_i, arctan(t_i/s_i))$\n你有兩種槍 一種槍射半徑$R$的圓形，消滅在圓形邊界上的所有飛彈\n另一種設出斜率$t/s$的直線，消滅相同線上的所有飛彈\n求最少開槍次數<!--more-->\n### 思路\n建一張圖，每種半徑、每種斜率都是一個點，\n邊則是飛彈(對於每個飛彈，把對應的半徑點和斜率點連在一起)\n問題轉化成**最小點覆蓋**問題\n(König定理：最小覆蓋點數==最大匹配數)\n用匈牙利算法算**二分圖最大匹配**獲得一個AC\n\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nvoid add_edge(int a, int b, vector<vector<int>> &graph) {\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n}\n\nbool dfs(int x, vector<int> &inpath, vector<int> &match,\n         vector<vector<int>> &graph) {\n    for (auto i : graph[x]) {\n        if (!inpath[i]) {\n            inpath[i] = true;\n            if (match[i] == -1 || dfs(match[i], inpath, match, graph)) {\n                match[x] = i;\n                match[i] = x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        map<int, int> circle_map;\n        map<pair<int, int>, int> line_map;\n        vector<vector<int>> graph(50000, vector<int>());\n        int cnt = 0, n;\n        cin >> n;\n        for (int i = 0; i < n; i++) {\n            int r, s, t;\n            cin >> r >> s >> t;\n            if (circle_map.count(r) == 0) circle_map[r] = cnt++;\n            int GCD = __gcd(s, t);\n            s /= GCD, t /= GCD;\n            if (line_map.count(make_pair(s, t)) == 0)\n                line_map[make_pair(s, t)] = cnt++;\n            add_edge(circle_map[r], line_map[make_pair(s, t)], graph);\n        }\n\n        int ans = 0;\n        vector<int> match(2 * n, -1);\n        vector<int> inpath;\n        for (auto &i : circle_map) {\n            inpath.clear();\n            inpath.resize(2 * n, 0);\n            if (dfs(i.second, inpath, match, graph)) ans++;\n        }\n        cout << ans << endl;\n    }\n}\n```\n","tags":["Hungarian"]},{"title":"[UVA] 10684 - The jackpot","url":"/2017/11/20/UVA-10684-The-jackpot/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1625\n### 題意\n最大連續和\n### 思路\n就典型的最大連續和\n一直加加加 加到負的就丟掉\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        int Max = 0, ans = 0;\n        while (n--) {\n            int tmp;\n            cin >> tmp;\n            Max += tmp;\n            if (Max < 0) Max = 0;\n            ans = max(ans, Max);\n        }\n        ans > 0 ? cout << \"The maximum winning streak is \" << ans << '.' << endl\n                : cout << \"Losing streak.\" << endl;\n    }\n}\n```\n","tags":["DP"]},{"title":"[UVA] 787 - Maximum Sub-sequence Product","url":"/2017/11/20/UVA-787-Maximum-Sub-sequence-Product/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=728\n### 題意\n輸入一串數字\n找出最大連續乘積\n最後的 -999999 不算\n### 思路\nDP，類似最大連續和的問題\n不過負最大的有可能翻盤變成最大的\n要同時保存最大和最小的\n這個方法可以在$O(n)$內解決\n<!--more-->\n題目的數字範圍有可能超過long long\n信Python得永生 \\O.O/\n### 程式碼\n```python\nimport sys\nimport math\n\n\ndef main():\n    for line in sys.stdin:\n        Max, Min, Lmax, Lmin = 1, 1, 1, 1\n        Ans = -math.inf\n        for i in map(int, line.split()[:-1]):\n            Max = max(Lmax * i, Lmin * i, i)\n            Min = min(Lmin * i, Lmax * i, i)\n            Ans = max(Ans, Max)\n            Lmax, Lmin = Max, Min\n        print(Ans)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n","tags":["DP"]},{"title":"[TIOJ] 1768 - 蹺蹺板 (Seesaw)","url":"/2017/11/15/TIOJ-1768-蹺蹺板-Seesaw/","content":"被別人問的\n### 出處\nhttp://tioj.ck.tp.edu.tw/problems/1768\n### 題意\n有個翹翹板上有N個等距座位，將支點架在任何一個座位的正下方。\n保證若把最前面$x$個人和最後面$x$個人交換，一定可以找到一個可以平衡的支點。\n$0\\leq x<\\lfloor{\\frac{N}{2}}\\rfloor$\n### 思路\n最值觀的想法就是搜每個$x$，對每個$x$再找他的支點位置，但這樣保證TLE。\n假設支點的位置是$k$，可以把翹翹板列成類似這樣的等式<!--more-->\n$(k-1)P_1+(k-2)P_2+(k-3)P_3+ ... = 0$\n化簡得 $k = (1 \\cdot P_1 + 2 \\cdot P_2 + 3 \\cdot P_3 ... ) \\div ( P_1 + P_2 + P_3 ... )$\n所以分別儲存除號左邊和右邊兩個數字，枚舉x，就可以把複雜度壓到$O(n)$，獲得一個AC。\n### 程式碼\n不是我寫的\n```cpp\n#include<stdio.h>\n\nint main()\n{\n    long long int n;\n    scanf(\"%lld\", &n);\n    long long int array[n+1], sum = 0, swap = 0;\n    long long int i, temp;\n    for(i = 1; i <= n; i++)\n    {\n        scanf(\"%lld\", &temp);\n        array[i] = temp;\n        swap += i * temp;\n        sum += temp;\n    }\n    if(swap % sum == 0) return printf(\"%d %lld\\n\", 0, swap / sum - 1), 0;\n    for(i = 0; i < n/2; i++)\n    {\n        if(i != 0) swap = swap - i * array[i] + (n+1-i) * array[i] - (n+1-i) * array[n+1-i] + i * array[n+1-i];\n        if(swap % sum == 0)\n        {\n            printf(\"%lld %lld\\n\", i, swap / sum - 1);\n            break;\n        }\n    }\n    return 0;\n}\n```\n","tags":["TIOJ"]},{"title":"GNU __built_in Bitwise Operations ","url":"/2017/11/14/GNU-built-in-Bitwise-Operations/","content":"GNU內建位元運算O(1)方法\n<!--more-->\n### 程式碼\n```cpp\nint __builtin_ffs (unsigned int x)\nint __builtin_ffsl (unsigned long)\nint __builtin_ffsll (unsigned long long)\n// Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero.\n\nint __builtin_clz (unsigned int x)\nint __builtin_clzl (unsigned long)\nint __builtin_clzll (unsigned long long)\n// Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined. \n\nint __builtin_ctz (unsigned int x)\nint __builtin_ctzl (unsigned long)\nint __builtin_ctzll (unsigned long long)\n// Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined. \n\nint __builtin_popcount (unsigned int x)\nint __builtin_popcountl (unsigned long)\nint __builtin_popcountll (unsigned long long)\n// Returns the number of 1-bits in x. \n\nint __builtin_parity (unsigned int x)\nint __builtin_parityl (unsigned long)\nint __builtin_parityll (unsigned long long)\n// Returns the parity of x, i.e. the number of 1-bits in x modulo 2.\n```\n","tags":["GNU_Built_in"]},{"title":"[Web] JavaScript 複製按鈕","url":"/2017/11/13/Web-JavaScript-複製按鈕/","content":"這個網站複製按鈕用的代碼\n從[這裡](https://github.com/Molunerfinn/hexo-theme-melody/blob/2962c028f34050b672f6028b05c91281f8b21dbb/source/js/copy.js)偷來的，實際上到底發生什麼事情，之後再研究XDDD\n研究完了，這Code怪怪的XDD\n<!--more-->\n### 程式碼\n```js\n$(function () {\n  // Add copy icon\n  var $copyIcon = $('<i class=\"fa fa-clipboard\" aria-hidden=\"true\"></i>')\n  var $notice = $('<div class=\"copy-notice\">asdsad</div>')\n  $('figure.highlight').prepend($copyIcon)\n  $('figure.highlight').prepend($notice)\n  // copy function\n  function copy (text, ctx) {\n    if (document.queryCommandSupported && document.queryCommandSupported('copy')) {\n      var textarea = document.createElement('textarea')\n      textarea.style.position = 'fixed' // Prevent scrolling to bottom of page in MS Edge.\n      document.body.appendChild(textarea)\n      textarea.textContent = text\n      textarea.focus()\n      textarea.setSelectionRange(0, textarea.value.length)\n      try {\n        document.execCommand('copy') // Security exception may be thrown by some browsers.\n        $(ctx).prev('.copy-notice').text(\"複製成功\").fadeIn();\n        setTimeout(function(){ $(ctx).prev('.copy-notice').fadeOut();}, 1000);\n      } catch (ex) {\n        $(ctx).prev('.copy-notice').text(\"複製失敗\").fadeIn();\n        setTimeout(function(){ $(ctx).prev('.copy-notice').fadeOut();}, 1000);\n        return false\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    } else {\n      $(ctx).prev('.copy-notice').text(\"瀏覽器不支援\")\n    }\n  }\n  // click events\n  $('.highlight .fa-clipboard').on('click', function () {\n    var selection = window.getSelection()\n    var range = document.createRange()\n    range.selectNodeContents($(this).next('table').find('.code pre')[0])\n    selection.removeAllRanges()\n    selection.addRange(range)\n    var text = selection.toString()\n    copy(text, this)\n    text = ''\n  })\n})\n```\n\n這份Code在Microsoft Edge沒辦法複製換行  \n稍微研究一下[clipboard.js](https://clipboardjs.com/)之後，\n新建一個`Textarea`應該是多餘的...吧\n總之移除之後就能正常運作，順便發個[PR](https://github.com/Molunerfinn/hexo-theme-melody/pull/8)\n```js\n$(function () {\n  // Add copy icon\n  var $copyIcon = $('<i class=\"fa fa-clipboard\" aria-hidden=\"true\" data-clipboard-target=\"#codes\"></i>')\n  var $notice = $('<div class=\"copy-notice\"></div>')\n  $('figure.highlight').prepend($copyIcon)\n  $('figure.highlight').prepend($notice)\n  // copy function\n  function copy(text, ctx) {\n    if (document.queryCommandSupported && document.queryCommandSupported('copy')) {\n      try {\n        document.execCommand('copy') // Security exception may be thrown by some browsers.\n        $(ctx).prev('.copy-notice').text(\"複製成功\").fadeIn();\n        setTimeout(function () { $(ctx).prev('.copy-notice').fadeOut(); }, 1000);\n      } catch (ex) {\n        $(ctx).prev('.copy-notice').text(\"複製失敗\").fadeIn();\n        setTimeout(function () { $(ctx).prev('.copy-notice').fadeOut(); }, 1000);\n        return false\n      }\n    } else {\n      $(ctx).prev('.copy-notice').text(\"瀏覽器不支援\")\n    }\n  }\n\n  // click events\n  $('.highlight .fa-clipboard').on('click', function () {\n    var selection = window.getSelection()\n    var range = document.createRange()\n    range.selectNodeContents($(this).next('table').find('.code pre')[0])\n    selection.removeAllRanges()\n    selection.addRange(range)\n    var text = selection.toString()\n    copy(text, this)\n    window.getSelection().removeAllRanges();\n  })\n})\n```\n","tags":["JavaScript"]},{"title":"[Web] JavaScript Throttle","url":"/2017/11/13/Web-JavaScript-Throttle/","content":"\n這個網站用的[主題](https://github.com/wa-ri/hexo-theme-ztopic)有個Bug，使用者快速上下捲動的時候，頂端NavBar會一閃一閃亮晶晶，主要原因是上一個動畫還沒完成，又要求下一個動作。\n\n簡單的解決方式是用製作一個簡單的Throttle[(詳細介紹)](https://keelii.github.io/2016/06/11/javascript-throttle/)\n<!--more-->\n## 程式碼\n```js\n  myFunc.throttle = function (func, wait, mustRun) { \n    var timeout;\n    var startTime = new Date();\n    return function () { \n      var context = this;\n      var args = arguments ;\n      var curTime = new Date() ;\n      clearTimeout(timeout);\n      if (curTime - startTime >= mustRun) { \n        func.apply(context, args);\n        startTime = curTime;\n      } else { \n        timeout = setTimeout(func, wait);\n      } \n    } \n  }; \n```\n之後關於Scroll的函數從\n```javascript\n$(window).scroll(function(){ \n    ...\n    }); \n```\n改成\n```javascript\n$(window).scroll(myFunc.throttle(function(){ \n    ...\n    }, 50, 500)); \n```\n","tags":["JavaScript"]},{"title":"[Web] Fixed & Transform Combo","url":"/2017/11/13/Web-Fixed-Transform-Combo/","content":"通常Fixed屬性只能Fixed在整個瀏覽器視窗中  \n但是[某木頭](https://s094392.github.io)Fixed他的複製按鈕居然可以Fixed在他的CodeBlock中  \n例如下面這一顆 左右滑動複製按鈕不會跟著滑動  \n```\ntest test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test\n```\n\n仔細研究，發現  \nhttps://developer.mozilla.org/en-US/docs/Web/CSS/position  \n<!--more-->\n>**`fixed`**\n>The element is removed from the normal document flow; no space is created for the element in the page layout. Instead, it is positioned relative to the screen's viewport and doesn't move when scrolled. Its final position is determined by the values of top, right, bottom, and left. This value always creates a new stacking context.**When an ancestor has the `transform` or `perspective` property set to something other than none, that ancestor is used as the container instead of the viewport (see CSS Transforms Spec)**In printed documents, the element is placed in the same position on every page.  \n\n也就是若祖先有`transform`或`perspective`，`fixed`就會把它當作容器，而不是整個viewport。\n某木頭的網頁就是整個inner container裡有個`transform: translateY(0px);`屬性，所以複製按鈕可以根據這個擺位置。\n\n```html\n<div class=\"layout\" id=\"content-inner\" style=\"opacity: 1; display: block; transform: translateY(0px);\">\n```\n這個網頁也如法炮製，是不是好作法不關我的事（？。\n","tags":["CSS"]},{"title":"[NCTUOJ] 254 - Worm Squares","url":"/2017/11/13/NCTUOJ-254-Worm-Squares/","content":"### 出處\nhttps://oj.nctu.me/problems/254/\n2017 NCTU Annual Programming Contest - L\n### 題意\nH必須接B，B必須接T\n求一組路線能夠經過最多組HBT\n### 思路\n建一個超級Source連到所有H，所有T連到超級Sink，容量全部為一\n跑一次Edmonds–Karp 求 MaxFlow\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\ninline int to_idx(int x, int y, int m) { return (x - 1) * m + y; }\n\ninline void add_edge(int u, int v, int w,\n                     vector<vector<pair<int, int>>> &graph) {\n    graph[u].push_back(make_pair(v, w));\n    graph[v].push_back(make_pair(u, 0));\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m;\n        cin >> n >> m;\n        cin.ignore();\n        vector<vector<char>> matrix(n + 2, vector<char>(m + 2));\n\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= m; j++) {\n                char tmp = cin.get();\n                if (tmp == '\\n') tmp = cin.get();\n                matrix[i][j] = tmp;\n            }\n\n        int source = 0, sink = m * n + 1;\n        vector<vector<pair<int, int>>> graph(m * n + 2,\n                                             vector<pair<int, int>>());\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int type, dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n                if (matrix[i][j] == 'H') {\n                    add_edge(source, to_idx(i, j, m), 1, graph);\n                    for (int k = 0; k < 4; k++)\n                        if (matrix[i + dx[k]][j + dy[k]] == 'B')\n                            add_edge(to_idx(i, j, m),\n                                     to_idx(i + dx[k], j + dy[k], m), 1, graph);\n                } else if (matrix[i][j] == 'B') {\n                    for (int k = 0; k < 4; k++)\n                        if (matrix[i + dx[k]][j + dy[k]] == 'T')\n                            add_edge(to_idx(i, j, m),\n                                     to_idx(i + dx[k], j + dy[k], m), 1, graph);\n                } else\n                    add_edge(to_idx(i, j, m), sink, 1, graph);\n            }\n        }\n        // cout << graph << endl;\n\n        int ans = 0;\n        while (true) {\n            queue<int> q;\n            q.push(source);\n            vector<pair<int, int>> pre(n * m + 2, make_pair(-1, -1));\n            while (!q.empty()) {\n                int x = q.front();\n                q.pop();\n                for (int i = 0; i < graph[x].size(); i++) {\n                    if (pre[graph[x][i].first].first == -1 &&\n                        graph[x][i].second > 0 && pre[sink].first == -1) {\n                        pre[graph[x][i].first] =\n                            make_pair(x, graph[x][i].second);\n                        q.push(graph[x][i].first);\n                    }\n                }\n            }\n            // cout << \"pre:\" << pre << endl;\n            if (pre[sink].first != -1) {\n                int Min = INF;\n                for (int i = 0; i < pre.size(); i++) {\n                    if (pre[i].first != -1 && Min > pre[i].second)\n                        Min = pre[i].second;\n                }\n                // cout << \"Min:\" << Min << endl;\n                int pos = sink;\n                while (pos != source) {\n                    for (auto &&j : graph[pre[pos].first])\n                        if (j.first == pos) j.second -= Min;\n                    for (auto &&j : graph[pos])\n                        if (j.first == pre[pos].first) j.second += Min;\n                    pos = pre[pos].first;\n                }\n                // cout << \"graph:\" << graph << endl;\n                ans += Min;\n            } else\n                break;\n        }\n        cout << ans << endl;\n    }\n}\n\n```\n","tags":["Flow"]},{"title":"[NCTUOJ] 3 - Hello World","url":"/2017/11/12/NCTUOJ-3-Hello-World/","content":"### 出處\nhttps://oj.nctu.me/problems/3/\n### 題意\n輸出\"Hello world!\"\n### 思路\n太難了，不知道怎麼寫，只好用python內建的\n<!--more-->\n### 程式碼\n```python\nimport __hello__\n```\n","tags":["Python"]},{"title":"[UVA] 183 - Bit Maps","url":"/2017/11/09/UVA-183-Bit-Maps/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=119\n### 題意\n兩種Bitmap表示方式，要求互相轉換\n(左上到底之後再換右上 類似DFS)\n### 思路\n遞迴模擬\n注意剩下一排的情況\n輸入和輸出都很麻煩\n<!--more-->\n### 程式碼\n```cpp\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nvoid BtoD(int i1, int i2, int j1, int j2, vector<vector<char>> &v,\n          string &ans) {\n    char flag = v[i1][j1];\n    for (int i = i1; i < i2; i++) {\n        for (int j = j1; j < j2; j++) {\n            if (v[i][j] != flag) {\n                flag = 'D';\n                break;\n            }\n        }\n        if (flag == 'D') break;\n    }\n    ans += flag;\n    if (flag != 'D') return;\n    int mi = (i2 - i1 + 1) / 2, mj = (j2 - j1 + 1) / 2;\n    BtoD(i1, i1 + mi, j1, j1 + mj, v, ans);\n    if (j2 - j1 > 1) BtoD(i1, i1 + mi, j1 + mj, j2, v, ans);\n    if (i2 - i1 > 1) {\n        BtoD(i1 + mi, i2, j1, j1 + mj, v, ans);\n        if (j2 - j1 > 1) BtoD(i1 + mi, i2, j1 + mj, j2, v, ans);\n    }\n}\n\nvoid DtoB(int i1, int i2, int j1, int j2, queue<char> &q,\n          vector<vector<char>> &ans) {\n    char flag = q.front();\n    q.pop();\n    if (flag != 'D') {\n        for (int i = i1; i < i2; i++) {\n            for (int j = j1; j < j2; j++) {\n                ans[i][j] = flag;\n            }\n        }\n        return;\n    }\n\n    int mi = (i2 - i1 + 1) / 2, mj = (j2 - j1 + 1) / 2;\n    DtoB(i1, i1 + mi, j1, j1 + mj, q, ans);\n    if (j2 - j1 > 1) DtoB(i1, i1 + mi, j1 + mj, j2, q, ans);\n    if (i2 - i1 > 1) {\n        DtoB(i1 + mi, i2, j1, j1 + mj, q, ans);\n        if (j2 - j1 > 1) DtoB(i1 + mi, i2, j1 + mj, j2, q, ans);\n    }\n}\n\nint main() {\n    char f;\n    int n, m;\n    while (cin >> f, f != '#') {\n        cin >> n >> m;\n        if (f == 'B') {\n            vector<vector<char>> v(n, vector<char>(m));\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    char tmp = cin.get();\n                    if (tmp == '\\n') tmp = cin.get();\n                    v[i][j] = tmp;\n                }\n            }\n            string ans = \"\";\n            BtoD(0, n, 0, m, v, ans);\n            int cnt = 0;\n            cout << \"D\" << right << setw(4) << n << right << setw(4) << m\n                 << endl;\n            for (auto &&i : ans) {\n                cnt++;\n                cout << i;\n                if (cnt == 50) {\n                    cnt = 0;\n                    cout << endl;\n                }\n            }\n            if (cnt != 0) cout << endl;\n        } else {\n            queue<char> q;\n            char tmp;\n            while (tmp = cin.get(), tmp != '#') {\n                if (cin.peek() == ' ') {\n                    cin.putback(tmp);\n                    break;\n                }\n                if (tmp == '\\n') continue;\n                q.push(tmp);\n            }\n            vector<vector<char>> ans(n, vector<char>(m));\n            DtoB(0, n, 0, m, q, ans);\n            int cnt = 0;\n            cout << \"B\" << right << setw(4) << n << right << setw(4) << m\n                 << endl;\n            for (auto &&i : ans) {\n                for (auto &&j : i) {\n                    cnt++;\n                    cout << j;\n                    if (cnt == 50) {\n                        cnt = 0;\n                        cout << endl;\n                    }\n                }\n            }\n            if (cnt != 0) cout << endl;\n            if (tmp == '#') break;\n        }\n    }\n}\n\n```\n","tags":["Recursive"]},{"title":"[UVA] 12032 - The Monkey and the Oiled Bamboo","url":"/2017/11/09/UVA-12032-The-Monkey-and-the-Oiled-Bamboo/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3183\n### 題意\n猴子一開始有k點力量，每次爬不能爬超過k距離，如果距離恰好等於k，則k-1，小於則k保持不變\n給定每隔高度，求最小K\n### 思路\n最好情況，K = 0\n最壞情況，每一格的間距都一樣高\n以此範圍二分搜K\n注意第一步也要注意力量夠不夠\n<!--more-->\n### 程式碼\n```python\nINF = 1000000000\n\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        N = int(input())\n        IN = list(map(int, input().split()))\n        Max = IN[0]\n        data = [IN[0]]\n        for i in range(len(IN) - 1):\n            data.append(IN[i + 1] - IN[i])\n            Max = max((IN[i + 1] - IN[i], Max))\n        left, right, mid = 0, len(data) + 1 + Max, 0\n        while left < right:\n            mid = (left + right) // 2\n            k = mid\n            for i in data:\n                if k < i:\n                    break\n                if i == k:\n                    k -= 1\n                if k < 0:\n                    break\n            else:\n                right = mid\n                continue\n            left = mid + 1\n        print(\"Case {}: {}\".format(t + 1, left))\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["BinarySearch"]},{"title":"[UVA] 11413 - Fill the Containers","url":"/2017/11/06/UVA-11413-Fill-the-Containers/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2408\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    while (cin >> n >> m) {\n        int Sum = 0;\n        int left = 0, right = Sum, mid;\n        vector<int> v(n);\n        for (int i = 0; i < n; i++) {\n            cin >> v[i];\n            right += v[i];\n            left = max(left, v[i]);\n        }\n\n        while (right > left) {\n            // cout << \"left:\" << left << endl;\n            // cout << \"right:\" << right << endl;\n            mid = (left + right) / 2;\n\n            // cout << \"mid:\" << mid << endl;\n            int tmp = 0, cnt = 0;\n            for (int i : v) {\n                tmp += i;\n                if (tmp == mid)\n                    tmp = 0, cnt++;\n                else if (tmp > mid)\n                    tmp = i, cnt++;\n            }\n            if (tmp > 0)\n                cnt++;\n\n            // cout << \"cnt:\" << cnt << endl << endl;\n\n            if (cnt > m)\n                left = mid + 1;\n            else\n                right = mid;\n        }\n        cout << left << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10341 - Solve It","url":"/2017/11/06/UVA-10341-Solve-It/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1282\n### 題意\n求 $p \\times e^{-x} + q \\times sin(x) + r \\times cos(x) + s \\times tan(x) + t \\times x^2 + u = 0$ 在 $ 0 \\leq x \\leq 1 $的解\n且輸入保證 $ 0 \\leq p, r \\leq 20 $、$ -20 \\leq q, s, t \\leq 0 $\n### 思路\n原方程式微分後得到\n$ -pe^{-x} + q \\cdot cos(x) + (-r \\cdot sin(x)) + s \\cdot sec^2(x) + 2tx $\n根據題目的限制，導函數永遠$\\leq 0$，原函數是遞減函數\n題目還給了$x$的範圍，直接二分搜答案\n<!--more-->\n### 程式碼\n```python\nimport math\nINF = 1000000000\n\n\ndef f(x, a):\n    return a[0] * math.exp(-x) + a[1] * math.sin(x) + a[2] * math.cos(x) + \\\n        a[3] * math.tan(x) + a[4] * x**2 + a[5]\n\n\ndef main():\n    while True:\n        try:\n            IN = list(map(int, input().split()))\n        except EOFError:\n            break\n        ans = 100000.0\n        left = 0\n        right = 1\n        while left < right:\n            ans = f((left + right) / 2, IN)\n            if abs(ans - 0) < 1e-9:\n                break\n            if ans < 0:\n                right = (left + right) / 2\n            else:\n                left = (left + right) / 2\n        else:\n            print(\"No solution\")\n            continue\n        print(\"{:.4f}\".format((left + right) / 2))\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["BinarySearch"]},{"title":"[UVA] 12455 - Bars","url":"/2017/11/03/UVA-12455-Bars/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3886\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\ndef dfs(depth, Sum, data, target, n):\n    if Sum > target:\n        return False\n    if Sum == target:\n        return True\n    if depth == n:\n        return False\n    if dfs(depth + 1, Sum + data[depth], data, target, n):\n        return True\n    else:\n        return dfs(depth + 1, Sum, data, target, n)\n\n\ndef main():\n    T = int(input())\n\n    for _ in range(T):\n        target = int(input())\n        n = int(input())\n        data = list(map(int, input().split()))\n        print(\"YES\") if dfs(0, 0, data, target, n) else print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 1203 - Argus","url":"/2017/11/03/UVA-1203-Argus/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3644\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000\n\nint main() {\n\tstring s;\n\tpriority_queue<tuple<int, int, int>> pq;\n\twhile (cin >> s, s[0] != '#') {\n\t\tint num, p;\n\t\tcin >> num >> p;\n\t\tpq.push(make_tuple(-p, -num, -p));\n\t}\n\tint k;\n\tcin >> k;\n\twhile (k--) {\n\t\tauto tmp = pq.top();\n\t\tcout << -get<1>(tmp) << endl;\n\t\tpq.pop();\n\t\tpq.push(make_tuple(get<2>(tmp) + get<0>(tmp),get<1>(tmp), get<2>(tmp)));\n\t}\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 12192 - Grapevine","url":"/2017/11/03/UVA-12192-Grapevine/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3344\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N | M) {\n        vector<vector<int>> v1(N, vector<int>(M)), v2(6000, vector<int>());\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                int tmp;\n                cin >> tmp;\n                v1[i][j] = tmp;\n                v2[j - i + 2500].push_back(tmp);\n            }\n        }\n\n        int Q;\n        cin >> Q;\n        while (Q--) {\n            int lb, ub;\n            int ans = 0;\n            cin >> lb >> ub;\n            for (int i = 0; i < N; i++) {\n                auto it = lower_bound(v1[i].begin(), v1[i].end(), lb);\n                if (it == v1[i].end())\n                    continue;\n                int j = distance(v1[i].begin(), it);\n                int pos = j - i + 2500;\n                auto it2 = upp1er_bound(v2[pos].begin(), v2[pos].end(), ub);\n                int tmp;\n                if (j - i < 0)\n                    tmp = distance(v2[pos].begin(), it2) - j;\n                else\n                    tmp = distance(v2[pos].begin(), it2) - i;\n                ans = max(ans, tmp);\n            }\n            cout << ans << endl;\n        }\n        cout << '-' << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11057 - Exact Sum","url":"/2017/11/03/UVA-11057-Exact-Sum/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1998\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nimport bisect\nINF = 1000000000\n\n\ndef main():\n    while True:\n        try:\n            N = int(input())\n            books = list(map(int, input().split()))\n            tar = int(input())\n            _ = input()\n        except EOFError:\n            break\n        books.sort()\n        ans1, ans2 = 0, 0\n        for idx, i in enumerate(books[:bisect.bisect_right(books, tar // 2 + 1)]):\n            try:\n                if books[bisect.bisect_left(books, tar - i, idx + 1)] == tar - i:\n                    ans1, ans2 = i, tar - i\n            except IndexError:\n                continue\n        print(\"Peter should buy books whose prices are {} and {}.\\n\".format(ans1, ans2))\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10567 - Helping Fill Bates","url":"/2017/11/02/UVA-10567-Helping-Fill-Bates/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1508\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#ifdef LOCAL\n#include \"stloutput.h\"\n#endif\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    char c;\n    vector<vector<int>> v(52, vector<int>());\n    int idx = 0;\n    while (c = cin.get(), c != '\\n')\n        v[c - 'a'].push_back(idx++);\n    int Q;\n    cin >> Q;\n    cin.ignore();\n    while (Q--) {\n        idx = -1;\n        int first = -1;\n        bool flag = true;\n        while (c = cin.get(), c != '\\n') {\n            auto it = upper_bound(v[c - 'a'].begin(), v[c - 'a'].end(), idx);\n            if (it == v[c - 'a'].end()) {\n                cout << \"Not matched\" << endl;\n                cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                flag = false;\n                break;\n            } else {\n                if (first == -1)\n                    first = *it;\n                idx = *it;\n            }\n        }\n        if (flag)\n            cout << \"Matched \" << first << \" \" << idx << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 1262 - Password","url":"/2017/11/01/UVA-1262-Password/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3703\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nINF = 1000000000\n\n\ndef dfs(x, table1, table2, cur, cnt, K, ans):\n    if cnt == K:\n        return cnt, ans\n    if x == 5:\n        cnt += 1\n        if cnt == K:\n            ans = list(cur)\n        return cnt, ans\n    for i in range(ord('A'), ord('Z') + 1):\n        if chr(i) in table1[x] and chr(i) in table2[x]:\n            cur.append(chr(i))\n            cnt, ans = dfs(x + 1, table1, table2, cur, cnt, K, ans)\n            cur.pop()\n    return (cnt, ans)\n\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        K = int(input())\n        table1, table2 = [[] for _ in range(5)], [[] for _ in range(5)]\n        for i in range(6):\n            for idx, j in enumerate(input()):\n                table1[idx].append(j)\n        for i in range(6):\n            for idx, j in enumerate(input()):\n                table2[idx].append(j)\n\n        ans = dfs(0, table1, table2, [], 0, K, [])[1]\n        if ans:\n            for i in ans:\n                print(i, end='')\n            print('')\n        else:\n            print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 416 - LED Test","url":"/2017/11/01/UVA-416-LED-Test/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=357\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nINF = 1000000000\n\nTABLE = [126, 48, 109, 121, 51, 91, 95, 112, 127, 123]\n\n\ndef dfs(x, cnt, data, broken):\n    if x == len(data):\n        return True\n    if cnt == -1:\n        return False\n    if not data[x] & (~TABLE[cnt]) and not data[x] & broken:\n        tmp = data[x] ^ TABLE[cnt]\n        return dfs(x + 1, cnt - 1, data, broken | tmp)\n\n\ndef main():\n    while True:\n        N = int(input())\n        if N == 0:\n            break\n\n        data = []\n        for _ in range(N):\n            data.append(int(input().replace('Y', '1').replace('N', '0'), 2))\n\n        for j in range(9, -1, -1):\n            if not data[0] & (~TABLE[j]):\n                broken = data[0] ^ TABLE[j]\n                if dfs(1, j - 1, data, broken):\n                    print(\"MATCH\")\n                    break\n        else:\n            print(\"MISMATCH\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 193 - Graph Coloring","url":"/2017/11/01/UVA-193-Graph-Coloring/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=129\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nvoid dfs(int x, vector<vector<int>> &graph, vector<bool> &black,\n         vector<int> &cur, vector<int> &ans) {\n    if (x == graph.size()) {\n        if (cur.size() > ans.size())\n            ans = cur;\n        return;\n    }\n    bool canbk = true;\n    for (auto i : graph[x])\n        if (black[i])\n            canbk = false;\n    if (canbk) {\n        black[x] = true;\n        cur.push_back(x + 1);\n        dfs(x + 1, graph, black, cur, ans);\n        cur.pop_back();\n        black[x] = false;\n    }\n    dfs(x + 1, graph, black, cur, ans);\n}\nint main() {\n    int m, n, k;\n    cin >> m;\n    while (m--) {\n        cin >> n >> k;\n        vector<vector<int>> graph(n, vector<int>());\n        for (int i = 0; i < k; i++) {\n            int t1, t2;\n            cin >> t1 >> t2;\n            t1--, t2--;\n            graph[t1].push_back(t2);\n            graph[t2].push_back(t1);\n        }\n        vector<bool> black(n);\n        vector<int> cur, ans;\n        dfs(0, graph, black, cur, ans);\n        cout << ans.size() << endl;\n        cout << ans[0];\n        for (int i = 1; i < ans.size(); i++)\n            cout << \" \" << ans[i];\n        cout << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10503 - The dominoes solitaire","url":"/2017/10/31/UVA-10503-The-dominoes-solitaire/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1444\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\nvoid dfs(pair<int, int> last, int d, int n, vector<pair<int, int>> &ve,\n         vector<pair<int, int>> &ver, vector<bool> &used, bool &ans,\n         pair<int, int> &v) {\n    if (ans)\n        return;\n    if (d == n && last.second == v.first) {\n        ans = true;\n        cout << \"YES\" << endl;\n        return;\n    }\n    for (int i = 0; i < ve.size(); i++) {\n        if (ve[i].first == last.second && !used[i] && !ans) {\n            used[i] = true;\n            dfs(ve[i], d + 1, n, ve, ver, used, ans, v);\n            used[i] = false;\n        } else if (ver[i].first == last.second && !used[i] && !ans) {\n            used[i] = true;\n            dfs(ver[i], d + 1, n, ve, ver, used, ans, v);\n            used[i] = false;\n        }\n    }\n}\nint main() {\n    int n, m;\n    while (cin >> n, n) {\n        cin >> m;\n        pair<int, int> u, v;\n        vector<pair<int, int>> ve, ver;\n        cin >> u.first >> u.second >> v.first >> v.second;\n        int t1, t2;\n        while (m--) {\n            cin >> t1 >> t2;\n            ve.push_back(make_pair(t1, t2));\n            ver.push_back(make_pair(t2, t1));\n        }\n        bool ans = false;\n        vector<bool> used(ve.size(), false);\n        dfs(u, 0, n, ve, ver, used, ans, v);\n        if (!ans)\n            cout << \"NO\" << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 1047 - Zones","url":"/2017/10/31/UVA-1047-Zones/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3488\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nvector<int> zone(1 << 20);\nvector<pair<int, int>> over;\n\nint ans, ansp;\n\nvoid dfs(int x, int pos, int n, int a) {\n    if (__builtin_popcount(pos) == a) {\n        int sum = 0, tmp = pos;\n        while (tmp != 0) {\n            int tmp2 = tmp & (-tmp);\n            tmp &= (~tmp2);\n            sum += zone[tmp2];\n        }\n        for (auto &&i : over) {\n            tmp = pos & i.first;\n            if (tmp) {\n                sum -= i.second * (__builtin_popcount(tmp) - 1);\n            }\n        }\n        if (sum > ans) {\n            ans = sum;\n            ansp = pos;\n        }\n        return;\n    }\n    for (int i = (x == 0) ? 1 : (x << 1); i <= (1 << (n - 1)); i <<= 1)\n        dfs(i, pos | i, n, a);\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    int n, a, tmp, T = 1;\n    while (cin >> n >> a, n + a != 0) {\n        zone.clear();\n        over.clear();\n        ans = -INF;\n        for (int i = 0; i < n; i++) {\n            cin >> tmp;\n            zone[1 << i] = tmp;\n        }\n        int m;\n        cin >> m;\n        while (m--) {\n            int t, pos = 0;\n            cin >> t;\n            while (t--) {\n                cin >> tmp;\n                pos |= (1 << (tmp - 1));\n            }\n            cin >> tmp;\n            over.push_back(make_pair(pos, tmp));\n        }\n        dfs(0, 0, n, a);\n        cout << \"Case Number  \" << T++ << endl;\n        cout << \"Number of Customers: \" << ans << endl;\n        cout << \"Locations recommended:\";\n        for (int i = 0; i < 20; i++)\n            if (ansp & (1 << i))\n                cout << ' ' << i + 1;\n        cout << endl << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 574 - Sum It Up","url":"/2017/10/31/UVA-574-Sum-It-Up/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=515\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nINF = 1000000000\n\n\ndef dfs(cur, ans, Sum, data, d, n, t):\n    if Sum > t:\n        return\n    if Sum == t and cur not in ans:\n        ans.append(list(cur))\n        return\n    if d == n:\n        return\n    cur.append(data[d])\n    dfs(cur, ans, Sum + data[d], data, d + 1, n, t)\n    cur.pop()\n    dfs(cur, ans, Sum, data, d + 1, n, t)\n    return (ans)\n\n\ndef main():\n    while True:\n        IN = list(map(int, input().split()))\n        t, n, data = IN[0], IN[1], IN[2:]\n        if t + n == 0:\n            break\n        print(\"Sums of {}:\".format(t))\n        ans = dfs([], [], 0, data, 0, n, t)\n        if ans:\n            for i in ans:\n                for j in i[:-1]:\n                    print(j, end='+')\n                print(i[-1])\n        else:\n            print(\"NONE\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 524 - Prime Ring Problem","url":"/2017/10/31/UVA-524-Prime-Ring-Problem/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=465\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nINF = 1000000000\n\n\ndef prime():\n    isprime = [True] * 32\n    for i in range(2, 32):\n        if isprime[i]:\n            for j in range(i + i, 32, i):\n                isprime[j] = False\n    return isprime\n\n\ndef dfs(cur, ans, last, depth, used, n, isprime):\n    if depth == n:\n        if isprime[cur[-1] + cur[0]]:\n            ans.append(list(cur))\n        return\n    for i in range(1, n + 1):\n        if not used[i] and isprime[last + i]:\n            used[i] = True\n            cur.append(i)\n            dfs(cur, ans, i, depth + 1, used, n, isprime)\n            cur.pop()\n            used[i] = False\n    return ans\n\n\ndef main():\n    T = 1\n    isprime = prime()\n    while True:\n        try:\n            n = int(input())\n        except EOFError:\n            break\n        if T != 1:\n            print('')\n        print(\"Case {}:\".format(T))\n        for i in dfs([1], [], 1, 1, [True, True] + [False] * (n - 1), n, isprime):\n            for j in i[:-1]:\n                print(j, end=' ')\n            print(i[-1])\n        T += 1\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11085 - Back to the 8-Queens","url":"/2017/10/30/UVA-11085-Back-to-the-8-Queens/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2026\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nINF = 1000000000\n\n\ndef queen(x, current, ans, d1, d2):\n    if x == 8:\n        ans.append(list(current))\n        return\n    for i in range(8):\n        if i not in current and not d1[x + i] and not d2[i - x]:\n            d1[x + i] = True\n            d2[i - x] = True\n            current.append(i)\n            queen(x + 1, current, ans, d1, d2)\n            d1[x + i] = False\n            d2[i - x] = False\n            current.pop()\n    return ans\n\n\ndef main():\n    pre = queen(0, [], [], [False] * 15, [False] * 15)\n    T = 1\n    while True:\n        try:\n            IN = [int(i) - 1 for i in input().split()]\n        except EOFError:\n            break\n        least = INF\n        for i in pre:\n            cnt = 0\n            for j in range(8):\n                if i[j] != IN[j]:\n                    cnt += 1\n            least = min(cnt, least)\n        print(\"Case {}: {}\".format(T, least))\n        T += 1\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 624 - CD","url":"/2017/10/30/UVA-624-CD/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=565\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\n\ndef dfs(depth, tr, Sum, ans, length, N, maxx):\n    if Sum > N:\n        return\n    if Sum > maxx[0]:\n        maxx[0] = Sum\n        maxx[1] = list(ans)\n    if depth == tr:\n        return\n    else:\n        ans.append(length[depth])\n        dfs(depth + 1, tr, Sum + length[depth], ans, length, N, maxx)\n        ans.pop()\n    dfs(depth + 1, tr, Sum, ans, length, N, maxx)\n\n\ndef main():\n    while True:\n        try:\n            IN = list(map(int, input().split()))\n        except EOFError:\n            break\n\n        N = IN[0]\n        tr = IN[1]\n        length = IN[2:]\n        maxx = [0, []]\n        dfs(0, tr, 0, [], length, N, maxx)\n        for i in maxx[1]:\n            print(i, end=' ')\n        print('sum:' + str(maxx[0]))\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10576 - Y2K Accounting Bug","url":"/2017/10/30/UVA-10576-Y2K-Accounting-Bug/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1517\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n    int s, d;\n    while (cin >> s >> d) {\n        int ans = -INF;\n        for (int k = 0; k < (1 << 12); k++) {\n            int v[8] = {};\n            int Sum = 0;\n            bool correct = true;\n            for (int i = 0; i < 12; i++) {\n                int tmp;\n                if (k & (1 << i))\n                    tmp = s;\n                else\n                    tmp = -d;\n                for (int j = max(0, (i - 4)); j <= min(i, 7); j++)\n                    v[j] += tmp;\n                if (i >= 4 && v[i - 4] > 0) {\n                    correct = false;\n                    break;\n                }\n                Sum += tmp;\n            }\n            if (correct)\n                ans = max(Sum, ans);\n        }\n        (ans > 0) ? cout << ans << endl : cout << \"Deficit\" << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11553 - Grid Game","url":"/2017/10/30/UVA-11553-Grid-Game/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2548\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\n\nusing namespace std;\nint ans;\nvoid dfs(int x, int d, vector<bool> &used, int n, vector<vector<int>> &v,\n         int sum) {\n    sum += v[d][x];\n    if (d == n - 1) {\n        ans = min(sum, ans);\n    }\n    used[x] = true;\n    for (int i = 0; i < n; i++) {\n        if (!used[i])\n            dfs(i, d + 1, used, n, v, sum);\n    }\n    used[x] = false;\n}\n\nint main() {\n    int T, n;\n    cin >> T;\n    while (T--) {\n        ans = INF;\n        cin >> n;\n        vector<vector<int>> v(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\n                cin >> v[i][j];\n        }\n        vector<bool> used(n);\n        for (int i = 0; i < n; i++)\n            dfs(i, 0, used, n, v, 0);\n        cout << ans << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11565 - Simple Equations","url":"/2017/10/28/UVA-11565-Simple-Equations/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2612\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\ndef main():\n    T = int(input())\n    for _ in range(T):\n        ans = False\n        a, b, c = list(map(int, input().split()))\n        for i in range(-100, 100):\n            if i == 0:\n                continue\n            if i > 0:\n                if i + i + i > a or i * i * i > b or i**2 + i**2 + i**2 > c:\n                    continue\n                for j in range(i + 1, b // i + 1):\n                    k = a - i - j\n                    if i + j + k == a and i * j * k == b and i**2 + j**2 + k**2 == c and k != j and k != i:\n                        print(i, j, k)\n                        ans = True\n                        break\n            if i < 0:\n                if i * i > b or i**2 + i**2 > c:\n                    continue\n                for j in range(i + 1, 0):\n                    k = a - i - j\n                    if i + j + k == a and i * j * k == b and i**2 + j**2 + k**2 == c and k != j and k != i:\n                        print(i, j, k)\n                        ans = True\n                        break\n            if ans:\n                break\n\n        if not ans:\n            print(\"No solution.\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11236 - Grocery store","url":"/2017/10/28/UVA-11236-Grocery-store/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2177\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#define INF 1000000000\n\nusing namespace std;\n\nint main() {\n\n    for (int a = 1; a + a + a + a <= 2000; a++) {\n        for (int b = a; a + b + b + b <= 2000; b++) {\n            for (int c = b; a + b + c + c <= 2000; c++) {\n                if (a * b * c > 1000000 &&\n                    1000000 * (a + b + c) % (a * b * c - 1000000) == 0) {\n                    int d = 1000000 * (a + b + c) / (a * b * c - 1000000);\n                    if (c <= d && a + b + c + d <= 2000)\n                        cout << fixed << setprecision(2) << (double)a / 100\n                             << ' ' << (double)b / 100 << ' ' << (double)c / 100\n                             << ' ' << (double)d / 100 << endl;\n                }\n            }\n        }\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10660 - Citizen attention offices","url":"/2017/10/28/UVA-10660-Citizen-attention-offices/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1601\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\n#define INF 1000000000\nusing namespace std;\n\nvoid preprocess(int x, int depth, vector<int> &v, vector<vector<int>> &comb) {\n    if (depth == 5) {\n        comb.push_back(v);\n        return;\n    }\n    for (int i = x + 1; i < 25 - (5 - depth) + 1; i++) {\n        v.push_back(i);\n        preprocess(i, depth + 1, v, comb);\n        v.pop_back();\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    vector<int> v;\n    vector<vector<int>> comb;\n    preprocess(-1, 0, v, comb);\n    int T;\n    cin >> T;\n    while (T--) {\n        vector<vector<int>> graph(5, vector<int>(5));\n        vector<pair<int, int>> data;\n        int N;\n        cin >> N;\n        while (N--) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = c;\n            data.push_back(make_pair(a, b));\n        }\n\n        int Min = INF;\n        vector<int> ans;\n        for (auto &&i : comb) {\n            int Sum = 0;\n            for (auto &&k : data) {\n                int tempMin = INF;\n                for (auto &&j : i) {\n                    int x = j / 5;\n                    int y = j % 5;\n                    tempMin =\n                        min(tempMin, abs(k.first - x) + abs(k.second - y));\n                }\n                tempMin *= graph[k.first][k.second];\n                Sum += tempMin;\n            }\n            if (Sum < Min) {\n                ans = i;\n                Min = Sum;\n            }\n        }\n\n        cout << ans[0];\n        for (int i = 1; i < ans.size(); i++)\n            cout << ' ' << ans[i];\n        cout << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11498 - Division of Nlogonia","url":"/2017/10/28/UVA-11498-Division-of-Nlogonia/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2493\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nwhile True:\n    K = int(input())\n    if K == 0:\n        break\n    n, m = map(int, input().split(' '))\n    for _ in range(K):\n        x, y = map(int, input().split(' '))\n        if (x == n or y == m):\n            print(\"divisa\")\n        elif (x > n and y > m):\n            print(\"NE\")\n        elif (x < n and y > m):\n            print(\"NO\")\n        elif (x < n and y < m):\n            print(\"SO\")\n        else:\n            print(\"SE\")\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11507 - Bender B. Rodríguez Problem","url":"/2017/10/28/UVA-11507-Bender-B-Rodriguez-Problem/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2502\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nmagic = {\n    '+x': {'+y': '+y', '-y': '-y', '+z': '+z', '-z': '-z'},\n    '-x': {'+y': '-y', '-y': '+y', '+z': '-z', '-z': '+z'},\n    '+y': {'+y': '-x', '-y': '+x', '+z': '+y', '-z': '+y'},\n    '-y': {'+y': '+x', '-y': '-x', '+z': '-y', '-z': '-y'},\n    '+z': {'+y': '+z', '-y': '+z', '+z': '-x', '-z': '+x'},\n    '-z': {'+y': '-z', '-y': '-z', '+z': '+x', '-z': '-x'}\n}\n\nwhile True:\n    L = int(input())\n    if L == 0:\n        break\n    now='+x'\n    for i in input().split():\n        if (i != 'No'):\n            now = magic[now][i]\n    print(now)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10462 - Is There A Second Way Left?","url":"/2017/10/28/UVA-10462-Is-There-A-Second-Way-Left/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1403\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000\n\nclass diset {\n  private:\n    vector<int> v;\n\n  public:\n    diset(int size) { v.resize(size, -1); }\n\n    int _find(int x) { return v[x] < 0 ? x : _find(v[x]); }\n\n    void _union(int x, int y) {\n        int a = _find(x);\n        int b = _find(y);\n        if (b < a)\n            swap(b, a);\n        v[a] += v[b];\n        v[b] = a;\n    }\n};\n\nclass edge {\n  public:\n    int u, v, w;\n    bool used;\n    edge() { u = -1, v = -1, w = 0, used = false; }\n    edge(int x, int y, int z) {\n        u = x;\n        v = y;\n        w = z;\n        used = false;\n    }\n    bool operator<(const edge &other) { return this->w < other.w; }\n};\n\nvoid dfs(int from, int x, int d, int w, vector<vector<edge>> &mst,\n         vector<bool> &visited, vector<int> &depth, vector<vector<int>> &parent,\n         vector<vector<int>> &longest) {\n    visited[x] = true;\n    depth[x] = d;\n    parent[x][0] = from;\n    longest[x][0] = w;\n    for (edge &i : mst[x])\n        if (!visited[i.v])\n            dfs(x, i.v, d + 1, i.w, mst, visited, depth, parent, longest);\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    int T;\n    cin >> T;\n    for (int t = 1; t <= T; t++) {\n        cout << \"Case #\" << t << \" : \";\n        int N, M;\n        cin >> N >> M;\n        vector<vector<int>> graph(N, vector<int>(N, INF));\n        vector<edge> elist;\n        for (int i = 0; i < M; i++) {\n            int t1, t2, t3;\n            cin >> t1 >> t2 >> t3;\n            t1--, t2--;\n            elist.push_back(edge(t1, t2, t3));\n            graph[t1][t2] = t3;\n            graph[t2][t1] = t3;\n        }\n\n        // kruskal\n        sort(elist.begin(), elist.end());\n        vector<vector<edge>> mst(N);\n        diset dset(N);\n        int cnt = 0, mst_len = 0;\n        for (edge &i : elist) {\n            if (dset._find(i.u) != dset._find(i.v)) {\n                i.used = true;\n                dset._union(i.u, i.v);\n                cnt++;\n                mst[i.u].push_back(edge(i.u, i.v, i.w));\n                mst[i.v].push_back(edge(i.v, i.u, i.w));\n                mst_len += i.w;\n            }\n            if (cnt == N - 1)\n                break;\n        }\n        if (cnt != N - 1) {\n            cout << \"No way\" << endl;\n            continue;\n        }\n        if (cnt == M) {\n            cout << \"No second way\" << endl;\n            continue;\n        }\n        // dfs\n        int d = 0;\n        vector<int> depth(N);\n        vector<vector<int>> parent(N, vector<int>(20)),\n            longest(N, vector<int>(20));\n        vector<bool> visited(N, false);\n        depth.resize(N);\n        dfs(0, 0, 0, 0, mst, visited, depth, parent, longest);\n\n        // LCA binary lift\n\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < N; i++) {\n                if (parent[i][j - 1] != -1) {\n                    parent[i][j] = parent[parent[i][j - 1]][j - 1];\n                    longest[i][j] = max(longest[i][j - 1],\n                                        longest[parent[i][j - 1]][j - 1]);\n                }\n            }\n        }\n\n        // edge not in mst\n        int ans = -INF, anspu, anspv;\n        for (edge &i : elist) {\n            if (i.used == false) {\n                int u = i.u, v = i.v, maxl = -INF;\n                int uu = u, vv = v;\n                if (depth[u] < depth[v])\n                    swap(u, v);\n                for (int j = 19; j >= 0; j--)\n                    if (depth[parent[u][j]] >= depth[v]) {\n\n                        maxl = max(maxl, longest[u][j]);\n                        u = parent[u][j];\n                    }\n                if (u == v) {\n                    if (ans == -INF) {\n                        ans = mst_len - maxl + i.w;\n                        anspv = vv;\n                        anspu = uu;\n                    } else {\n                        if (ans > mst_len - maxl + i.w) {\n                            ans = mst_len - maxl + i.w;\n                            anspv = vv;\n                            anspu = uu;\n                        }\n                    }\n                    continue;\n                }\n                for (int j = 19; j >= 0; j--) {\n                    if (parent[u][j] != parent[v][j]) {\n                        maxl = max(maxl, max(longest[u][j], longest[v][j]));\n                        u = parent[u][j], v = parent[v][j];\n                    }\n                }\n                maxl = max(maxl, max(longest[u][0], longest[v][0]));\n                if (ans == -INF) {\n                    ans = mst_len - maxl + i.w;\n                    anspv = vv;\n                    anspu = uu;\n                } else {\n                    if (ans > mst_len - maxl + i.w) {\n                        ans = mst_len - maxl + i.w;\n                        anspv = vv;\n                        anspu = uu;\n                    }\n                }\n            }\n        }\n        ans == -INF ? cout << 0 << endl : cout << ans << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11799 - Horror Dash","url":"/2017/10/28/UVA-11799-Horror-Dash/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2899\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#define INF 1000000000\n\nint main(){\n\tint T;\n\tcin>>T;\n\tfor (int i = 1; i <= T; i++){\n\t\tint N,c,max = -1;\n\t\tcin>>N;\n\t\twhile (N--){\n\t\t\tcin>>c;\n\t\t\tif (c > max) max = c;\n\t\t}\n\t\tcout<<\"Case \"<<i<<\": \"<<max<<endl;\n\t}\n\n\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10855 - Rotated square","url":"/2017/10/27/UVA-10855-Rotated-square/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1796\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000\n\nint main() {\n    int N, n;\n    while (cin >> N >> n, N | n) {\n        string big[N], small[4][n];\n        for (int i = 0; i < N; i++)\n            cin >> big[i];\n        for (int i = 0; i < n; i++)\n            cin >> small[0][i];\n        string s(n, '-');\n        for (int k = 1; k < 4; k++)\n            for (int i = 0; i < n; i++)\n                small[k][i] = s;\n\n        for (int k = 1; k < 4; k++)\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    small[k][j][n - i - 1] = small[k - 1][i][j];\n        int ans[4] = {};\n        for (int k = 0; k < 4; k++) {\n            for (int i = 0; i < N - n + 1; i++) {\n                int pos = -1, pos2;\n                while (true) {\n                    pos = big[i].find(small[k][0], pos + 1);\n                    if (pos != -1) {\n                        bool flag = true;\n                        for (int j = 1; j < n; j++) {\n                            pos2 = big[i + j].find(small[k][j], pos);\n                            if (pos2 != pos) {\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if (flag)\n                            ans[k] += 1;\n                    } else\n                        break;\n                }\n            }\n        }\n        bool first = true;\n        for (int i = 0; i < 4; i++) {\n\n            if (!first)\n                cout << ' ';\n            first = false;\n            cout << ans[i];\n        }\n        cout << endl;\n    }\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10102 - The path in the colored field","url":"/2017/10/25/UVA-10102-The-path-in-the-colored-field/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1043\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nfrom collections import deque\n\nwhile True:\n    try:\n        T = int(input())\n    except EOFError:\n        break\n    graph = []\n    for t in range(T):\n        tmp = [int(i) for i in input()]\n        graph.append(tmp)\n\n    ans = -1\n    for i in range(T):\n        for j in range(T):\n            if graph[i][j] == 1:\n                q = deque([(i, j, 0)])\n                visited = [[False] * T for i in range(T)]\n                while len(q) != 0:\n                    if graph[q[0][0]][q[0][1]] == 3:\n                        ans = max(ans, q[0][2])\n                        break\n                    if q[0][0] > 0 and visited[q[0][0] - 1][q[0][1]] is False:\n                        q.append((q[0][0] - 1, q[0][1], q[0][2] + 1))\n                        visited[q[0][0] - 1][q[0][1]] = True\n                    if q[0][1] > 0 and visited[q[0][0]][q[0][1] - 1] is False:\n                        q.append((q[0][0], q[0][1] - 1, q[0][2] + 1))\n                        visited[q[0][0]][q[0][1] - 1] = True\n                    if q[0][0] < T - 1 and visited[q[0][0] + 1][q[0][1]] is False:\n                        visited[q[0][0] + 1][q[0][1]] = True\n                        q.append((q[0][0] + 1, q[0][1], q[0][2] + 1))\n                    if q[0][1] < T - 1 and visited[q[0][0]][q[0][1] + 1] is False:\n                        visited[q[0][0]][q[0][1] + 1] = True\n                        q.append((q[0][0], q[0][1] + 1, q[0][2] + 1))\n                    q.popleft()\n    print(ans)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 735 - Dart-a-Mania","url":"/2017/10/25/UVA-735-Dart-a-Mania/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=676\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <set>\n\n#define INF 1000000000\nusing namespace std;\n\n\nvoid dfs(int x, int depth, int score, int &cnt,\n         set<int> & se, vector<int>& v, set<set<int>>& sese) {\n\tv.push_back(x);\n\tscore -= x;\n\tif (depth == 3 && score == 0) {\n\t\tcnt++;\n\t\tset<int> tmp;\n\t\tfor (auto && i : v)\n\t\t\ttmp.insert(i);\n\t\tsese.insert(tmp);\n\t}\n\tif (depth == 3 || score < 0) {\n\t\tv.pop_back();\n\t\treturn;\n\t}\n\tfor (auto && i : se)\n\t\tdfs(i , depth + 1, score, cnt, se, v, sese);\n\tv.pop_back();\n}\n\n\nint main() {\n\tset<int> se;\n\tfor (int i = 1; i <= 20; i++)\n\t\tfor (int j = 1; j <= 3; j++)\n\t\t\tse.insert(i * j);\n\tse.insert(0);\n\tse.insert(50);\n\tint n;\n\twhile (cin >> n, n > 0) {\n\t\tint cnt = 0;\n\t\tvector<int> v;\n\t\tset<set<int>> sese;\n\t\tdfs(0, 0, n, cnt, se, v, sese);\n\t\tif (cnt == 0) {\n\t\t\tcout << \"THE SCORE OF \" << n << \" CANNOT BE MADE WITH THREE DARTS.\"<<endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NUMBER OF COMBINATIONS THAT SCORES \" << n << \" IS \" << sese.size() << \".\" << endl;\n\t\t\tcout << \"NUMBER OF PERMUTATIONS THAT SCORES \" << n << \" IS \" << cnt << \".\" << endl;\n\t\t}\n\t\tcout << \"**********************************************************************\" << endl;\n\t}\n\tcout << \"END OF OUTPUT\" << endl;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 441 - Lotto","url":"/2017/10/25/UVA-441-Lotto/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=382\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nfirst = True\nwhile True:\n    IN = list(map(int, input().split()))\n    N, IN = IN[0], IN[1:]\n    if N == 0:\n        break\n    if not first:\n        print('')\n    first = False\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                for l in range(k + 1, N):\n                    for m in range(l + 1, N):\n                        for n in range(m + 1, N):\n                            print(str(IN[i]) + ' ' + str(IN[j]) + ' ' + str(IN[k]) +\n                                  ' ' + str(IN[l]) + ' ' + str(IN[m]) + ' ' + str(IN[n]))\n\n```\n","tags":["UVA"]},{"title":"[UVA] 12060 - All Integer Average","url":"/2017/10/24/UVA-12060-All-Integer-Average/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3212\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nfrom fractions import Fraction\nT = 0\nwhile True:\n    IN = list(map(int, input().split()))\n    if IN[0] == 0:\n        break\n    Sum = sum(IN[1:])\n    T += 1\n    ans = Fraction(Sum, len(IN) - 1)\n    print(\"Case {}:\".format(T))\n    if ans.denominator == 1:\n        if ans < 0:\n            print('-', end=' ')\n        print(abs(ans))\n    else:\n        wh = '' if ans.numerator >= 0 else \"- \"\n        de = ans.denominator\n        nu = abs(ans.numerator) % de\n        if abs(ans.numerator) // de != 0:\n            wh += str(abs(ans.numerator) // de)\n        maxl = max(len(str(nu)), len(str(de))) + len(wh)\n        print('{a:>{w}}'.format(a=nu, w=maxl))\n        print(wh, end=\"\")\n        print('-' * (maxl - len(wh)))\n        print('{a:>{w}}'.format(a=de, w=maxl))\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10487 - Closest Sums","url":"/2017/10/24/UVA-10487-Closest-Sums/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1428\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nimport bisect\n\nT = 1\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    print(\"Case {}:\".format(T))\n    T += 1\n    data = []\n    for n in range(N):\n        data.append(int(input()))\n    sums = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            sums.append(data[i] + data[j])\n    N = int(input())\n    sums.sort()\n    for n in range(N):\n        tmp = int(input())\n        pos = bisect.bisect_right(sums, tmp)\n        if pos == 0:\n            ans = sums[0]\n        elif pos == len(sums):\n            ans = sums[-1]\n        else:\n            if abs(sums[pos] - tmp) < abs(sums[pos - 1] - tmp):\n                ans = sums[pos]\n            else:\n                ans = sums[pos - 1]\n        print(\"Closest sum to {} is {}.\".format(tmp, ans))\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11242 - Tour de France","url":"/2017/10/24/UVA-11242-Tour-de-France/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2183\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\n#define INF 1000000000\nusing namespace std;\n\nint main() {\n\twhile (1) {\n\t\tint f, r;\n\t\tcin >> f;\n\t\tif (f == 0) break;\n\t\tcin >> r;\n\t\tvector<int> F(f), R(r);\n\t\tfor (int i = 0; i < f; i++)\n\t\t\tcin >> F[i];\n\t\tfor (int i = 0; i < r; i++)\n\t\t\tcin >> R[i];\n\n\t\tvector<double> sp;\n\t\tfor (int& i : F)\n\t\t\tfor (int& j : R)\n\t\t\t\tsp.push_back((double)i / j);\n\n\t\tsort(begin(sp),end(sp));\n\t\tdouble Max = -1.0;\n\t\tfor (int i = 0; i < sp.size()-1; i++) \n\t\t\tMax = max(Max,sp[i+1]/sp[i]);\n\t\tcout<<fixed<<setprecision(2)<<Max<<endl;\n\t}\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 1260 - Sales","url":"/2017/10/24/UVA-1260-Sales/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3701\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    data = []\n    data += list(map(int, input().split()))\n    ans = 0\n    for i in range(1, N):\n        for j in range(i - 1, -1, -1):\n            if data[i] >= data[j]:\n                ans += 1\n    print(ans)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10976 - Fractions Again?!","url":"/2017/10/24/UVA-10976-Fractions-Again/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1917\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nfrom fractions import Fraction\n\nwhile True:\n    try:\n        k = int(input())\n    except EOFError:\n        break\n\n    cnt = 0\n    ans = \"\"\n    for y in range(k + 1, 2 * k + 1):\n        if (Fraction(1, k) - Fraction(1, y)).numerator == 1:\n            cnt += 1\n            ans += (\"1/{} = 1/{} + 1/{}\\n\".format(k,\n                                                  (Fraction(1, k) - Fraction(1, y)).denominator, y))\n    print(cnt)\n    print(ans, end=\"\")\n\n```\n","tags":["UVA"]},{"title":"[UVA] 1237 - Expert Enough?","url":"/2017/10/24/UVA-1237-Expert-Enough/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3678\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nT = int(input())\n\nfor t in range(T):\n    data = []\n    N = int(input())\n    for n in range(N):\n        IN = input().split()\n        data.append((IN[0], int(IN[1]), int(IN[2])))\n    N = int(input())\n    for n in range(N):\n        IN = int(input())\n        ans = \"\"\n        for i in data:\n            if i[1] <= IN <= i[2]:\n                if ans != \"\":\n                    print(\"UNDETERMINED\")\n                    break\n                else:\n                    ans = i[0]\n        else:\n            print(ans) if ans != \"\" else print(\"UNDETERMINED\")\n    if t != T - 1:\n        print('')\n\n```\n","tags":["UVA"]},{"title":"[UVA] 927 - Integer Sequences from Addition of Terms","url":"/2017/10/24/UVA-927-Integer-Sequences-from-Addition-of-Terms/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=868\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nT = int(input())\nfor t in range(T):\n    an = [int(i) for i in input().split()]\n    d = int(input())\n    k = int(input())\n    Sum = 0\n    cnt = 1\n    while True:\n        Sum += d * cnt\n        if Sum >= k:\n            break\n        else:\n            cnt += 1\n    ans = 0\n    p = 0\n    for i in an[1:]:\n        ans += i * (cnt ** p)\n        p += 1\n    print(ans)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 12532 - Interval Product","url":"/2017/10/23/UVA-12532-Interval-Product/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3977\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\nusing namespace std;\n\nclass segtree {\nprivate:\n\tstruct node {\n\t\tint neg = 0, zero = 0;\n\n\t};\n\tvector<node> v;\n\tvector<int>* data;\npublic:\n\tsegtree(vector<int>* x) {\n\t\tv.resize(1000000);\n\t\tdata = x;\n\t\tbuild(0, 0, data->size() - 1);\n\t}\n\tvoid build (int x, int L, int R) {\n\t\tif (L == R) {\n\t\t\tif (data->at(L) < 0)\n\t\t\t\tv[x].neg = 1;\n\t\t\telse if (data->at(L) == 0)\n\t\t\t\tv[x].zero = 1;\n\t\t\treturn;\n\t\t}\n\t\tbuild (2 * x + 1, L, (L + R) / 2);\n\t\tbuild (2 * x + 2, (L + R) / 2 + 1, R);\n\t\tv[x].neg = v[2 * x + 1].neg + v[2 * x + 2].neg;\n\t\tv[x].zero = v[2 * x + 1].zero + v[2 * x + 2].zero;\n\t}\n\tvoid update(int x, int L, int R, int pos, int val) {\n\t\t//cout<<\"L:\"<<L<<endl;\n\t\t//cout<<\"R:\"<<R<<endl;\n\t\tif (L > pos || R < pos) return;\n\t\tif (L == pos && R == pos) {\n\t\t\tif (val == 0)\n\t\t\t\tv[x].neg = 0, v[x].zero = 1;\n\t\t\telse if (val < 0)\n\t\t\t\tv[x].neg = 1, v[x].zero = 0;\n\t\t\telse\n\t\t\t\tv[x].neg = 0, v[x].zero = 0;\n\t\t\treturn;\n\t\t}\n\t\tupdate(2 * x + 1, L, (L + R) / 2, pos, val);\n\t\tupdate(2 * x + 2, (L + R) / 2 + 1, R, pos, val);\n\t\tv[x].neg = v[2 * x + 1].neg + v[2 * x + 2].neg;\n\t\tv[x].zero = v[2 * x + 1].zero + v[2 * x + 2].zero;\n\t}\n\tpair<int, int> query(int x, int L, int R, int tL, int tR) {\n\t\tif (L > tR || R < tL) return make_pair(0,0);\n\t\tif (tL <= L && R <= tR) return make_pair(v[x].neg,v[x].zero);\n\t\tauto p1 = query(2 * x + 1, L, (L + R) / 2, tL, tR);\n\t\tauto p2 =  query(2 * x + 2, (L + R) / 2 + 1, R, tL, tR);\n\t\treturn  make_pair(p1.first+p2.first,p1.second+p2.second);\n\t\t      \n\t}\n};\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tint N, K;\n\twhile (cin >> N >> K) {\n\t\tvector <int> data(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> data[i];\n\t\tsegtree t(&data);\n\t\twhile (K--) {\n\t\t\tchar c;\n\t\t\tint a, b;\n\t\t\tcin >> c >> a >> b;\n\t\t\tif (c == 'C') {\n\t\t\t\ta--;\n\t\t\t\tt.update(0, 0, N - 1, a, b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta--, b--;\n\t\t\t\tauto tmp = t.query(0, 0, N - 1, a, b);\n\t\t\t\tif (tmp.second > 0) cout << 0;\n\t\t\t\telse if (tmp.first %2 == 1) cout << '-';\n\t\t\t\telse cout << '+';\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11402 - Ahoy, Pirates!","url":"/2017/10/23/UVA-11402-Ahoy-Pirates/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2397\n### 題意\n區間都變1，區間都變0，區間Inverse\n### 思路\n線段樹\n我自己是開了兩個懶標記<!--more-->\n`status`-1表示正常，0代表全部都是0，1代表全部都是1\n`inverse`代表區間取反\n不過在推標記的時候要注意各種情況，例如本來inverse被全部變1就要把inverse取消之類的。\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#define INF 1000000000\nusing namespace std;\n\nclass segtree {\nprivate:\n\tstruct node {\n\t\tint val = 0, len = 0, status = -1; //nothing  allzero allone\n\t\tbool inverse = false;\n\t};\n\tvector<int>* data;\n\tvector<node> v;\npublic:\n\tsegtree(vector<int>* x) {\n\t\tv.resize(1024000 * 3 + 10);\n\t\tdata = x;\n\t\tbuild (0, 0, data->size() - 1);\n\t}\n\n\tvoid build(int x, int left, int right) {\n\t\tif (left == right) {\n\t\t\tv[x].val = data->at(left);\n\t\t\tv[x].len = 1;\n\t\t\treturn;\n\t\t}\n\t\tbuild (2 * x + 1, left, (left + right) / 2);\n\t\tbuild (2 * x + 2, (left + right) / 2 + 1, right);\n\t\tv[x].val = v[2 * x + 1].val + v[2 * x + 2].val;\n\t\tv[x].len = v[2 * x + 1].len + v[2 * x + 2].len;\n\t}\n\n\tvoid push_down(int x) {\n\t\tif (v[x].status == -1 && !v[x].inverse) return;\n\t\telse if ((v[x].status == 0 && !v[x].inverse) ||\n\t\t         (v[x].status == 1 &&  v[x].inverse)) {\n\t\t\tv[2 * x + 1].status = 0;\n\t\t\tv[2 * x + 2].status = 0;\n\t\t\tv[2 * x + 1].inverse = false;\n\t\t\tv[2 * x + 2].inverse = false;\n\t\t\tv[2 * x + 1].val = 0;\n\t\t\tv[2 * x + 2].val = 0;\n\t\t\tv[x].status = -1;\n\t\t\tv[x].inverse = false;\n\t\t}\n\t\telse if ((v[x].status == 1 && !v[x].inverse) ||\n\t\t         (v[x].status == 0 &&  v[x].inverse)) {\n\t\t\tv[2 * x + 1].status = 1;\n\t\t\tv[2 * x + 2].status = 1;\n\t\t\tv[2 * x + 1].inverse = false;\n\t\t\tv[2 * x + 2].inverse = false;\n\t\t\tv[2 * x + 1].val = v[2 * x + 1].len;\n\t\t\tv[2 * x + 2].val = v[2 * x + 2].len;\n\t\t\tv[x].status = -1;\n\t\t\tv[x].inverse = false;\n\t\t}\n\t\telse if (v[x].inverse) {\n\t\t\tv[2 * x + 1].val = v[2 * x + 1].len - v[2 * x + 1].val;\n\t\t\tv[2 * x + 2].val = v[2 * x + 2].len - v[2 * x + 2].val;\n\t\t\tv[2 * x + 1].inverse ^= true;\n\t\t\tv[2 * x + 2].inverse ^= true;\n\t\t\tv[x].inverse = false;\n\t\t}\n\t\telse cout << \"Not Suppose to Happen\" << endl;\n\t\t//print();\n\t}\n\n\tint query(int x, int left, int right, int tleft, int tright) {\n\t\tif (tright < left || tleft > right) return 0;\n\t\tif (tleft <= left && tright >= right) return v[x].val;\n\t\tpush_down(x);\n\t\treturn query(2 * x + 1, left, (left + right) / 2, tleft, tright) +\n\t\t       query(2 * x + 2, (left + right) / 2 + 1, right, tleft, tright);\n\t}\n\n\tvoid update(int x, int left, int right, int tleft, int tright, char type) {\n\t\tif (tright < left || tleft > right) return;\n\t\tif (tleft <= left && tright >= right) {\n\t\t\tif (type == 'F') {\n\t\t\t\tv[x].status = 1;\n\t\t\t\tv[x].val = v[x].len;\n\t\t\t\tv[x].inverse = false;\n\t\t\t}\n\t\t\telse if (type == 'E') {\n\t\t\t\tv[x].status = 0;\n\t\t\t\tv[x].val = 0;\n\t\t\t\tv[x].inverse = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[x].inverse ^= true;\n\t\t\t\tv[x].val = v[x].len - v[x].val;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpush_down(x);\n\t\tupdate(2 * x + 1, left, (left + right) / 2, tleft, tright, type);\n\t\tupdate(2 * x + 2, (left + right) / 2 + 1, right, tleft, tright, type);\n\t\tv[x].val = v[2 * x + 1].val + v[2 * x + 2].val;\n\t}\n\n\tvoid print() {\n\t\tfor (int i = 0; i < data->size() * 2; i++) {\n\t\t\tcout << i << \": \" << v[i].val << ' ' << v[i].len << ' ' << v[i].status << ' ' << v[i].inverse << endl;\n\t\t}\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(0);\n\tint T;\n\tcin >> T;\n\tfor (int t = 1; t <= T; t++) {\n\t\tvector<int> data;\n\t\tint N;\n\t\tcin >> N;\n\t\twhile (N--) {\n\t\t\tint M;\n\t\t\tchar c;\n\t\t\tvector<int> tmp;\n\t\t\tcin >> M;\n\t\t\tcin.ignore();\n\t\t\twhile (c = cin.get(), c != '\\n')\n\t\t\t\ttmp.push_back(c - '0');\n\t\t\twhile (M--)\n\t\t\t\tdata.insert(data.end(), tmp.begin(), tmp.end());\n\t\t}\n\t\tsegtree magic(&data);\n\t\tcin >> N;\n\t\tcout << \"Case \" << t << \":\" << endl;\n\t\tint q = 1;\n\t\twhile (N--) {\n\t\t\t//magic.print();\n\t\t\tchar c;\n\t\t\tint a, b;\n\t\t\tcin >> c >> a >> b;\n\t\t\tif (c == 'S') {\n\t\t\t\tcout << \"Q\" << q++ << \": \";\n\t\t\t\tcout << magic.query(0, 0, data.size() - 1, a, b) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmagic.update(0, 0, data.size() - 1, a, b, c);\n\t\t\t}\n\t\t\t//magic.print();\n\t\t}\n\t\t//magic.print();\n\t}\n\n}\n\n```\n","tags":["SegmentTree"]},{"title":"[UVA] 11235 - Frequent values","url":"/2017/10/20/UVA-11235-Frequent-values/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2176\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <utility>\n\n#define INF 1000000000\nusing namespace std;\n\n\n\nint main() {\n\tint n, q;\n\twhile (cin >> n,n){\n\t\tcin>>q;\n\t\tvector<int> v(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> v[i];\n\t\t}\n\t\tint last = v[0], idx = 0, cnt = 0, b = 0;\n\t\tvector<int> toseg(n);\n\t\tvector<vector<int>> st(17, vector<int>(2 << 17, -INF));\n\t\tvector<pair<int, int>> data(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (v[i] != last) {\n\t\t\t\tst[0][idx] = cnt;\n\t\t\t\tb = i;\n\t\t\t\tidx++;\n\t\t\t\tcnt = 0;\n\t\t\t\tlast  = v[i];\n\t\t\t}\n\t\t\ttoseg[i] = idx;\n\t\t\tdata[i].first = b;\n\t\t\tcnt++;\n\t\t}\n\t\tst[0][idx++] = cnt;\n\t\tb = n - 1;\n\t\tlast = v[n - 1];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (v[i] != last) {\n\t\t\t\tb = i;\n\t\t\t\tlast = v[i];\n\t\t\t}\n\t\t\tdata[i].second = b;\n\t\t}\n\n\t\tfor (int i = 1; i < 16; i++) {\n\t\t\tfor (int j = 0; j < idx; j++) {\n\t\t\t\tst[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);\n\t\t\t}\n\t\t}\n\n\t\twhile (q--) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tu--, v--;\n\t\t\tif (data[u].first == data[v].first) cout << v - u + 1 << endl;\n\t\t\telse {\n\t\t\t\tint maxa = data[u].second - u + 1;\n\t\t\t\tint maxb = v - data[v].first + 1,maxc=-INF;\n\t\t\t\tint uu = toseg[u] + 1, vv = toseg[v] - 1;\n\t\t\t\tif (uu != vv+1){\n\t\t\t\t\tint p = 31 -  __builtin_clz(vv-uu);\n\t\t\t\t\tmaxc = max(st[p][vv - (1 << p) + 1], st[p][uu]);\n\t\t\t\t}\n\t\t\t\tcout<<max(maxa,max(maxb,maxc))<<endl;\n\t\t\t}\n\t\t}\n\t}\n\n/*\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t//cout << \"st[i][j]:\" << st[i][j] << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\tfor (auto i : data)\n\t\t//cout << \"i.first:\" << i.first << \" \" << i.second << endl;\n\tfor (auto i : toseg)\n\t\t//cout << \"i:\" << i << endl;*/\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11503 - Virtual Friends","url":"/2017/10/19/UVA-11503-Virtual-Friends/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2498\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\ndef _find(x):\n    if type(dset[x]) == int:\n        return x\n    else:\n        dset[x] = _find(dset[x])\n        return dset[x]\n\n\ndef _union(x, y):\n    a = _find(x)\n    b = _find(y)\n    if a != b:\n        if dset[a] > dset[b]:\n            a, b = b, a\n        dset[a] += dset[b]\n        dset[b] = a\n    return -dset[a]\n\n\nT = int(input())\nfor t in range(T):\n    dset = {}\n    F = int(input())\n    for f in range(F):\n        n1, n2 = input().split()\n        if n1 not in dset:\n            dset[n1] = -1\n        if n2 not in dset:\n            dset[n2] = -1\n        print(_union(n1, n2))\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10507 - Waking up brain","url":"/2017/10/19/UVA-10507-Waking-up-brain/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1448\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M){\n\t\tvector<vector<int>> v(26, vector<int>());\n\t\tvector<bool> wake(26, false);\n\t\tcin.ignore();\n\t\twake[cin.get() - 'A'] = true;\n\t\twake[cin.get() - 'A'] = true;\n\t\twake[cin.get() - 'A'] = true;\n\t\tcin.ignore();\n\t\twhile (M--) {\n\t\t\tint c, d;\n\t\t\tc = cin.get() - 'A';\n\t\t\td = cin.get() - 'A';\n\t\t\tv[c].push_back(d);\n\t\t\tv[d].push_back(c);\n\t\t\tcin.ignore();\n\t\t}\n\t\tint ans = 0;\n\t\twhile (1) {\n\t\t\tans++;\n\t\t\tvector<int> sw;\n\t\t\tfor (int i = 0; i < 26; i++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tif (!wake[i]) {\n\t\t\t\t\tfor (auto j : v[i])\n\t\t\t\t\t\tif (wake[j]) cnt++;\n\t\t\t\t\tif (cnt >= 3) sw.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sw.size() == 0) break;\n\t\t\telse {\n\t\t\t\tfor (auto i : sw){\n\t\t\t\t\tN--;\n\t\t\t\t\twake[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tN==3?cout << \"WAKE UP IN, \" << ans - 1 << \", YEARS\" << endl:cout<<\"THIS BRAIN NEVER WAKES UP\"<<endl;\n\t}\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 793 - Network Connections","url":"/2017/10/19/UVA-793-Network-Connections/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=734\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\n\n\ndef _find(x):\n    if dset[x] < 0:\n        return x\n    else:\n        dset[x] = _find(dset[x])\n        return dset[x]\n\n\ndef _union(x, y):\n    a = _find(x)\n    b = _find(y)\n    if a == b:\n        return\n    if dset[a] > dset[b]:\n        a, b = b, a\n    dset[a] += dset[b]\n    dset[b] = a\n\n\nT = int(input())\ninput()\nfor t in range(T):\n    N = int(input())\n    us = 0\n    s = 0\n    dset = [-1] * (N + 1)\n    while True:\n        try:\n            c, u, v = input().split()\n        except Exception:\n            break\n        u = int(u)\n        v = int(v)\n        if c == 'c':\n            _union(u, v)\n        else:\n            if _find(u) != _find(v):\n                us += 1\n            else:\n                s += 1\n    print(str(s) + ',' + str(us))\n    if t != T - 1:\n        print()\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10895 - Matrix Transpose","url":"/2017/10/19/UVA-10895-Matrix-Transpose/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1836\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nfrom sys import stdin\n\nwhile True:\n    try:\n        m, n = map(int, stdin.readline().split())\n    except ValueError:\n        break\n\n    matrix = [[0] * (n + 1) for i in range(m + 1)]\n\n    for i in range(1, m + 1):\n        in1 = list(map(int, stdin.readline().split()))\n        in2 = list(map(int, stdin.readline().split()))\n        for j in range(1, in1[0] + 1):\n            matrix[i][in1[j]] = in2[j - 1]\n\n    print(n, m)\n    for j in range(1, n + 1):\n        cnt = 0\n        la = []\n        lb = []\n        for i in range(1, m + 1):\n            if matrix[i][j] != 0:\n                cnt += 1\n                la.append(i)\n                lb.append(matrix[i][j])\n\n        if cnt != 0:\n            print(cnt, end=' ')\n        else:\n            print(cnt, end='')\n        for k in la[:-1]:\n            print(k, end=\" \")\n        if len(la) > 0:\n            print(la[-1], end='')\n        print('')\n        for k in lb[:-1]:\n            print(k, end=\" \")\n        if (len(lb) > 0):\n            print(lb[-1], end='')\n        print('')\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10901 - Ferry Loading III","url":"/2017/10/18/UVA-10901-Ferry-Loading-III/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1842\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000\n\t\t\n\n\nint main() {\n\tint c;\n\tbool first  = true;\n\tcin >> c;\n\twhile (c--) {\n\t\tint n, t, m;\n\t\tcin >> n >> t >> m;\t\n\t\tvector<queue<int>> car(2), cari(2);\n\t\tfor (int i = 0 ; i < m; i++) {\n\t\t\tstring s;\n\t\t\tint tmp;\n\t\t\tcin >> tmp >> s;\n\t\t\tif (s == \"left\") car[0].push(tmp), cari[0].push(i);\n\t\t\telse car[1].push(tmp), cari[1].push(i);\n\t\t}\n\t\tint timestamp = 0, boat = 0;\n\t\tbool side = 0;\n\t\tvector<int> ans(m);\n\t\twhile (!car[0].empty() || !car[1].empty()) {\n\t\t\tboat = 0;\n\t\t\t//cout<<\"n: \"<<n<<endl;\n\t\t\twhile (!car[side].empty() && car[side].front() <= timestamp && boat < n) {\n\t\t\t\tboat++;\n\t\t\t\t//cout<<\"boat: \"<<boat<<endl;\n\t\t\t\t//cout<<\"car[side].front(): \"<<car[side].front()<<endl;\n\t\t\t\tcar[side].pop();\n\t\t\t\tans[cari[side].front()] = timestamp + t;\n\t\t\t\tcari[side].pop();\n\t\t\t}\n\n\t\t\tif (!car[side].empty() && boat == 0 && (car[side^1].empty() || \n\t\t\t\tcar[side ^ 1].front() >= car[side].front())) {\n\t\t\t\ttimestamp = car[side].front();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (boat == 0) {\n\t\t\t\ttimestamp = max(car[side ^ 1].front() + t, timestamp + t);\n\t\t\t\t//cout<<\"timestamp: \"<<timestamp<<endl;\n\t\t\t\tside ^= 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttimestamp += t;\n\t\t\tside ^= 1;\n\t\t\t//ans[i] = timestamp;\n\t\t\t//cout<<\"boat: \"<<boat<<endl;\n\t\t\t//cout << \"timestamp: \" << timestamp << endl;\n\t\t}\n\t\tif (!first) cout << endl;\n\t\tfirst = false;\n\t\tfor (int i : ans)\n\t\t\tcout << i << endl;\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 599 - The Forrest for the Trees","url":"/2017/10/14/UVA-599-The-Forrest-for-the-Trees/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=540\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <vector>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000\n\nint graph[30][30], visit[30];\nbool dfs(int start) {\n\tvisit[start] = true;\n\tbool onlyone = true;\n\tfor (int i = 0; i < 30; i++) {\n\t\tif (graph[start][i]) {\n\t\t\tonlyone = false;\n\t\t\tif (! visit[i])\n\t\t\t\tdfs(i);\n\t\t}\n\t}\n\treturn onlyone;\n}\n\n\nint main() {\n\n\tint T;\n\tchar ch;\n\tscanf(\"%d\", &T);\n\tch = getchar();\n\twhile (T--) {\n\n\t\tchar u, v;\n\t\tmemset(graph, 0, sizeof(graph));\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tchar s[1000];\n\t\twhile (true) {\n\t\t\tgets(s);\n\t\t\tif (s[0] == '*') break;\n\t\t\tu -= 'A', v -= 'A';\n\t\t\tgraph[s[1] - 'A'][s[3] - 'A'] = 1;\n\t\t\tgraph[s[3] - 'A'][s[1] - 'A'] = 1;\n\t\t}\n\n\n\t\tchar c;\n\t\tvector<int> node;\n\t\twhile (c = getchar(), c != '\\n') {\n\t\t\tif (c == ',') continue;\n\t\t\tnode.push_back(c - 'A');\n\t\t}\n\t\tint tree = 0, lonely = 0;\n\t\tfor (auto i : node) {\n\t\t\tif (!visit[i])\n\t\t\t\t!dfs(i) ? tree += 1 : lonely += 1;\n\t\t}\n\t\tprintf(\"There are %d tree(s) and %d acorn(s).\\n\", tree, lonely);\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11849 - CD","url":"/2017/10/14/UVA-11849-CD/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2949\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nfrom sys import stdin\n\nwhile True:\n    N, M = map(int, stdin.readline().split())\n    if N + M == 0:\n        break\n    se = set()\n    for i in range(N):\n        se.add(int(stdin.readline()))\n    ans = 0\n    for i in range(M):\n        if int(stdin.readline()) in se:\n            ans += 1\n    print(ans)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11136 - Hoax or what","url":"/2017/10/14/UVA-11136-Hoax-or-what/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2077\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000\n\nint main() {\n\tint n;\n\twhile (cin >> n, n)\t{\n\t\tint k, tmp, id=0;\n\t\tlong long ans = 0;\n\t\tmultiset<int> se;\n\n\t\twhile (n--) {\n\t\t\tcin >> k;\n\t\t\tfor (int i = 0; i < k ;i++) {\n\t\t\t\tcin>>tmp;\n\t\t\t\tse.insert(tmp);\n\t\t\t}\n\t\t\tauto b = se.begin(), e = --se.end();\n\t\t\tans += (*e - *b);\n\t\t\tse.erase(b);\n\t\t\tse.erase(e);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10172 - The Lonesome Cargo Distributor","url":"/2017/10/13/UVA-10172-The-Lonesome-Cargo-Distributor/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1113\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nfrom collections import deque\n\nSET = int(input())\nfor _ in range(SET):\n    N, S, Q = map(int, input().split())\n    platform = []\n    sumLen = 0\n    for i in range(N):\n        temp = input().split()\n        sumLen += int(temp[0])\n        platform.append(deque([int(i) - 1 for i in temp[1:]]))\n\n    car = []\n    pos = 0\n    time = 0\n\n    while True:\n        while len(car) > 0:\n            if car[-1] == pos:\n                car.pop()\n                sumLen -= 1\n            elif len(platform[pos]) < Q:\n                platform[pos].append(car[-1])\n                car.pop()\n            else:\n                break\n            time += 1\n        while len(platform[pos]) > 0 and len(car) < S:\n            car.append(platform[pos].popleft())\n            time += 1\n        pos += 1\n        if pos == N:\n            pos = 0\n        if sumLen == 0:\n            print(time)\n            break\n        time += 2\n\n```\n","tags":["UVA"]},{"title":"[UVA] 978 - Lemmings Battle!","url":"/2017/10/13/UVA-978-Lemmings-Battle/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=919\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nimport heapq\nfrom sys import stdin\nN = int(stdin.readline())\nfor j in range(N):\n    B, SG, SB = map(int, stdin.readline().split())\n    gh, bh = [], []\n    for _ in range(SG):\n        heapq.heappush(gh, int(stdin.readline()) * -1)\n    for _ in range(SB):\n        heapq.heappush(bh, int(stdin.readline()) * -1)\n\n    while len(gh) > 0 and len(bh) > 0:\n        bf = []\n        for i in range(B):\n            tmp = []\n            if len(gh) > 0:\n                tmp.append(heapq.heappop(gh))\n            else:\n                tmp.append(0)\n            if len(bh) > 0:\n                tmp.append(heapq.heappop(bh))\n            else:\n                tmp.append(0)\n            bf.append(tmp)\n\n        for i in bf:\n            tmp = i[0] - i[1]\n            if tmp < 0:\n                heapq.heappush(gh, tmp)\n            elif tmp > 0:\n                heapq.heappush(bh, -tmp)\n\n    if len(gh) == 0 and len(bh) == 0:\n        print(\"green and blue died\")\n    elif len(gh) == 0:\n        print(\"blue wins\")\n        while len(bh) > 0:\n            print(-heapq.heappop(bh))\n\n    else:\n        print(\"green wins\")\n        while len(gh) > 0:\n            print(-heapq.heappop(gh))\n    if j != N - 1:\n        print('')\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11572 - Unique Snowflakes","url":"/2017/10/12/UVA-11572-Unique-Snowflakes/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2619\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nfrom sys import stdin\nT = int(stdin.readline())\nfor _ in range(T):\n    n = int(stdin.readline())\n    Max = 0\n    li = [-1] * 1000000\n    st = 0\n    for i in range(n):\n        inin = int(stdin.readline())\n        if li[inin] >= st:\n            st = li[inin] + 1\n        li[inin] = i\n        Max = max(Max, i - st + 1)\n    print(Max)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 573 - The Snail","url":"/2017/10/12/UVA-573-The-Snail/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=514\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#define INF 1000000000\n\nint main() {\n\tint H, U, D, F;\n\twhile (cin >> H >> U >> D >> F, H != 0) {\n\t\tdouble pos = 0.0;\n\t\tdouble fatigue = (double)U * F / 100, up = U;\n\t\tbool success = false;\n\t\tint day = 0;\n\t\twhile (true) {\n\t\t\tday ++ ;\n\t\t\tpos += up;\n\t\t\tif (pos > H) {\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos -= D;\n\t\t\tif (pos < 0) break;\n\t\t\tup -= fatigue;\n\t\t\tif (up < 0) up = 0;\n\t\t}\n\t\tsuccess ? cout << \"success on day \" << day << endl : cout << \"failure on day \" << day << endl;\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11286 - Conformity","url":"/2017/10/12/UVA-11286-Conformity/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2261\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000 \n\t\t\nint main(){\n\tint n;\n\twhile (cin>>n, n){\n\t\tmap<set<int>,int> m;\n\t\tint tmp;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tset<int> se;\n\t\t\tfor (int i = 0; i < 5; i++){\n\t\t\t\tcin>>tmp;\n\t\t\t\tse.insert(tmp);\n\t\t\t}\n\t\t\tm[se] += 1;\n\t\t}\n\t\tint Max = -1, ans = 0;\n\t\tfor (auto i : m)\n\t\t\tif (i.second > Max) Max = i.second;\n\t\tfor (auto i : m)\n\t\t\tif (i.second == Max) ans+=Max;\n\t\tcout<<ans<<endl;\n\t}\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11034 - Ferry Loading IV","url":"/2017/10/12/UVA-11034-Ferry-Loading-IV/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1975\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nfrom collections import deque\n\nc = int(input())\nfor _ in range(c):\n    l, m = map(int, input().split())\n\n    car = [deque(), deque()]\n    for i in range(m):\n        inin = input().split()\n        if inin[1] == \"left\":\n            car[0].append(int(inin[0]))\n        else:\n            car[1].append(int(inin[0]))\n\n    l *= 100\n    side = 0\n    ans = 0\n    while len(car[0]) + len(car[1]) > 0:\n        boat = 0\n        while len(car[side]) > 0 and l - boat > car[side][0]:\n            boat += car[side].popleft()\n        side ^= True\n        ans += 1\n        # print(car)\n    print(ans)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 1062 - Containers","url":"/2017/10/06/UVA-1062-Containers/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3503\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000\n\t\t\nint main(){\n\tstring s;\n\tint T = 1;\n\twhile (getline(cin,s), s != \"end\"){\n\t\tvector<int> v(s.length(),1);\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t\tfor (int j = i+1; j < s.length(); j++)\n\t\t\t\tif (s[i] < s[j]) v[j] = max(v[j], v[i]+1);\n\t\tcout<<\"Case \"<<T++<<\": \"<<*max_element(v.begin(), v.end())<<endl;\n\t}\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 732 - Anagrams by Stack","url":"/2017/10/06/UVA-732-Anagrams-by-Stack/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=673\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\ndef magic(move, pos):\n    if pos == len(target):\n        for i in range(len(ans)):\n            print(ans[i], end='')\n            if i != len(ans) - 1:\n                print(' ', end='')\n        print('')\n        return\n    if move:\n        pos += 1\n        final.append(mid[-1])\n        mid.pop()\n        ans.append('o')\n    else:\n        if len(source) > 0:\n            ans.append('i')\n            mid.append(source[-1])\n            source.pop()\n        else:\n            return\n    if len(mid) > 0 and mid[-1] == target[pos]:\n        magic(False, pos)\n        magic(True, pos)\n    else:\n        magic(False, pos)\n    if move:\n        pos -= 1\n        mid.append(final[-1])\n        final.pop()\n        ans.pop()\n    else:\n        source.append(mid[-1])\n        mid.pop()\n        ans.pop()\n\n\nwhile True:\n    try:\n        source = [i for i in input()]\n        target = [i for i in input()]\n        source = source[::-1]\n    except EOFError:\n        break\n\n    mid = []\n    final = []\n    ans = []\n    pos = 0\n    print('[')\n    magic(False, 0)\n    print(']')\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11926 - Multitasking","url":"/2017/10/05/UVA-11926-Multitasking/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3077\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000 \n\t\t\nint main(){\n\tint n,m;\n\twhile (cin>>n>>m,n|m){\n\t\tbitset<2000000> bs;\n\t\tbool con = false;\n\t\twhile (n--){\n\t\t\tint t1,t2;\n\t\t\tcin>>t1>>t2;\n\t\t\tif (!con)\n\t\t\t\tfor (int i = t1*2+1; i <= t2*2  && i < 2000000; i++){\n\t\t\t\t\tif(bs[i] != 0)  con = true;\n\t\t\t\t\telse bs.set(i);\n\t\t\t\t}\n\t\t}\n\t\twhile (m--){\n\t\t\tint t1,t2,t3;\n\t\t\tcin>>t1>>t2>>t3;\n\t\t\tif (!con)\n\t\t\t\twhile (t1 < 1000000){\n\t\t\t\t\tfor (int i = t1*2+1; i <= t2*2 && i < 2000000; i++){\n\t\t\t\t\t\tif(bs[i] != 0) con = true;\n\t\t\t\t\t\telse bs.set(i);\n\t\t\t\t\t}\n\t\t\t\t\tif (con) break;\n\t\t\t\t\tt1+=t3;\n\t\t\t\t\tt2+=t3;\n\t\t\t\t}\n\t\t}\n\t\tcon?cout<<\"CONFLICT\"<<endl:cout<<\"NO CONFLICT\"<<endl;\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11933 - Splitting Numbers","url":"/2017/10/05/UVA-11933-Splitting-Numbers/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3084\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nwhile True:\n    n = int(input())\n    a, b = 0, 0\n    flag = True\n    if n == 0:\n            break\n    while n:\n        tmp = n & (-n)\n        if flag:\n            a = a | tmp\n        else:\n            b = b | tmp\n        flag ^= True\n        n ^= tmp\n    print(a, b)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10264 - The Most Potent Corner","url":"/2017/10/05/UVA-10264-The-Most-Potent-Corner/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1205\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000 \n\t\t\nint main(){\n\tint N;\n\twhile (cin>>N){\n\t\tN = 1 << N;\n\t\tvector<int> v1(N,0),v2(N,0);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin>>v1[i];\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tint sum = 0;\n\t\t\tfor (int magic = 1; magic ^ N; magic<<=1)\n\t\t\t\tsum+=v1[i^magic];\n\t\t\tv2[i] = sum;\n\t\t}\n\t\tint Max = -INF;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int magic = 1; magic ^ N; magic<<=1)\n\t\t\t\tMax = max(Max,v2[i] + v2[i^magic]);\n\t\t}\n\t\tcout<<Max<<endl;\n\t}\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10258 - Contest Scoreboard","url":"/2017/10/05/UVA-10258-Contest-Scoreboard/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1199\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nT = int(input())\ninput()\nfor cnt in range(T):\n    penalty = [[0] * 9 for i in range(100)]\n    score = [[i, 0, 0, 0] for i in range(100)]\n    while True:\n        try:\n            temp = input().split()\n            if len(temp) <= 0:\n                break\n        except EOFError:\n            break\n        stuff = [int(temp[i]) for i in range(3)]\n        score[stuff[0] - 1][3] = 1\n        if temp[3] == 'I' and penalty[stuff[0] - 1][stuff[1] - 1] != -1:\n            penalty[stuff[0] - 1][stuff[1] - 1] += 20\n        elif temp[3] == 'C' and penalty[stuff[0] - 1][stuff[1] - 1] != -1:\n            score[stuff[0] - 1][1] += 1\n            score[stuff[0] - 1][2] += penalty[stuff[0] -\n                                              1][stuff[1] - 1] + stuff[2]\n            penalty[stuff[0] - 1][stuff[1] - 1] = -1\n    score.sort(key=lambda x: (-x[1], x[2], -x[3]))\n    for i in score:\n        if i[3] == 0:\n            break\n        print(\"{} {} {}\".format(i[0] + 1, i[1], i[2]))\n    if cnt != T - 1:\n        print('')\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11581 - Grid Successors","url":"/2017/10/05/UVA-11581-Grid-Successors/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2628\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000 \n\nvector<int> magic(vector<int> &v){\n\tvector<int> temp(9,0);\n\ttemp[0] = (v[1] + v[3]) % 2;\n\ttemp[2] = (v[1] + v[5]) % 2;\n\ttemp[6] = (v[3] + v[7]) % 2;\n\ttemp[8] = (v[5] + v[7]) % 2;\n\ttemp[1] = (v[0] + v[4] + v[2]) % 2;\n\ttemp[3] = (v[0] + v[4] + v[6]) % 2;\n\ttemp[5] = (v[8] + v[4] + v[2]) % 2;\n\ttemp[7] = (v[6] + v[4] + v[8]) % 2;\n\treturn temp;\n}\n\nint main(){\n\tint T;\n\tcin>>T;\n\tcin.ignore();\n\twhile(T--){\n\t\tcin.ignore();\n\t\tvector<int> v(9,0),z(9,0);\n\t\tvector<vector<int>> vv;\n\t\tfor (int i = 0; i < 9; i++){\n\t\t\tchar temp = cin.get();\n\t\t\tif (temp == '\\n') temp = cin.get();\n\t\t\tv[i] = temp - '0';\n\t\t}\n\t\n\t\tint cnt = -1;\n\t\twhile (true){\n\t\t\t/*cout<<\"cnt: \"<<cnt<<endl;\n\t\t\tfor(auto&& i : v) {\n\t\t\t\tcout<<i<<' ';\n\t\t\t}\n\t\t\tcout<<endl;*/\n\t\t\tif (v == z) break;\n\t\t\tbool flag = false;\n\t\t\tfor (auto&& i:vv)\n\t\t\t\tif (v == i){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) break;\n\t\t\tvv.push_back(v);\n\t\t\tv = magic(v);\n\t\t\tcnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t\t\n\t}\t\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10920 - Spiral Tap","url":"/2017/10/02/UVA-10920-Spiral-Tap/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1861\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000 \n\t\t\nint main(){\n\tll SZ,P;\n\twhile (cin>>SZ>>P,P+SZ){\n\t\tll x=(SZ-1)/2,y=(SZ-1)/2,now = 1,direction = 0,length = 2;\n\t\twhile (now != P){\n\t\t\tint temp = length/2;\n\t\t\tif (now + temp <= P)\n\t\t\t\tswitch(direction%4){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tnow +=temp, y+=temp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tnow +=temp, x-=temp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tnow +=temp, y-=temp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tnow +=temp, x+=temp;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tswitch(direction%4){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tfor (ll i = 0; i  < length/2 && now != P; i++)\n\t\t\t\t\t\t\tnow++,y++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tfor (ll i = 0; i  < length/2 && now != P; i++)\n\t\t\t\t\t\t\tnow++,x--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tfor (ll i = 0; i  < length/2 && now != P; i++)\n\t\t\t\t\t\t\tnow++,y--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tfor (ll i = 0; i  < length/2 && now != P; i++)\n\t\t\t\t\t\t\tnow++,x++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tdirection++;\n\t\t\tlength++;\n\t\t}\n\t\tcout<<\"Line = \"<<y+1<<\", column = \"<<x+1<<'.'<<endl;\n\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 12626 - I ❤ Pizza","url":"/2017/09/29/UVA-12626-I-❤-Pizza/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=4349\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main(){\n\tint N,i;\n\tchar c,*s = \"MARGARITA\";\n\tscanf(\"%d\",&N);\n\tc = getchar();\n\twhile (N--){\n\t\tint cnt[26];\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\twhile (c = getchar(),c!='\\n')\n\t\t\tcnt[c-'A']++;\n\t\tint min = (1 << 20);\n\t\t\n\t\tcnt['A'-'A']/=3;\n\t\tcnt['R'-'A']/=2;\n\t\tfor (i = 0; i < 9; i++){\n\t\t\tif (cnt[s[i] - 'A'] < min) min = cnt[s[i] - 'A'];\n\t\t}\n\t\tprintf(\"%d\\n\",min);\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 146 - ID Codes","url":"/2017/09/29/UVA-146-ID-Codes/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=82\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000 \n\nint main(){\n\tchar s[1000];\n\twhile (cin>>s,s[0] != '#'){\n\t\tbool next = next_permutation(s,s+strlen(s));\n\t\tnext?cout<<s<<endl:cout<<\"No Successor\"<<endl;\n\t}\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 12250 - Language Detection","url":"/2017/09/28/UVA-12250-Language-Detection/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3402\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nlan = {\"HELLO\":\"English\",\n\t\"HOLA\":\"Spanish\",\n\t\"HALLO\":\"German\",\n\t\"BONJOUR\":\"French\",\n\t\"CIAO\":\"Italian\",\n\t\"ZDRAVSTVUJTE\":\"Russian\"}\n\ni = 1\nwhile True:\n\ts = input()\n\tif s == \"#\":\n\t\tbreak\n\tprint(\"Case {}: \".format(i),end='')\n\ti+=1\n\ttry:\n\t\tprint (lan.get(s).upper())\n\texcept:\n\t\tprint (\"UNKNOWN\")\n\n```\n","tags":["UVA"]},{"title":"[UVA] 1124 - Celebrity jeopardy","url":"/2017/09/28/UVA-1124-Celebrity-jeopardy/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3565\n### 題意\n輸入什麼，就輸出什麼\n### 思路\nHmm...\n<!--more-->\n### 程式碼\n```python\nwhile True:\n\ttry:\n\t\ts = input()\n\texcept:\n\t\tbreak\n\tprint (s)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 12356 - Army Buddies","url":"/2017/09/27/UVA-12356-Army-Buddies/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3778\n### 題意\n一堆士兵(1 ~ S)站成一排\n子彈射過某個區間(L ~ R)，區間內士兵全部死亡\n輸出離區間外離兩端點最近的\n\n不會鞭屍(`You may assume that until that moment those soldiers were alive and were just killed. `)\n### 思路\n用類似LinkedList的方法解決\n每個士兵有三個屬性(編號、左邊同胞的編號、右邊同胞的編號)\n被射的時候就輸出左邊那位的左邊同胞，右邊也是\n最後把左邊的左邊同胞接上右邊的右邊同胞 即完成一次射擊\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000 \n\t\t\nint main(){\n\tint S,B;\n\tbool flag = true;\n\twhile (cin>>S>>B){\n\t\tif (!flag) cout<<'-'<<endl;\n\t\tflag = false;\n\t\tpair<int,int> soldiers[100000]; \n\t\tfor (int i = 1; i <= S; i++){\n\t\t\tsoldiers[i].first = i - 1,soldiers[i].second = i + 1;\n\t\t}\n\t\twhile (B--){\n\t\t\tint L,R;\n\t\t\tcin>>L>>R;\n\t\t\tsoldiers[L].first <= 0?cout<<\"* \":cout<<soldiers[L].first<<' ';\n\t\t\tsoldiers[R].second > S?cout<<\"*\"<<endl:cout<<soldiers[R].second<<endl;\n\t\t\tsoldiers[soldiers[L].first].second = soldiers[R].second;\n\t\t\tsoldiers[soldiers[R].second].first = soldiers[L].first;\n\t\t}\n\t}\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11340 - Newspaper","url":"/2017/09/27/UVA-11340-Newspaper/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <unordered_map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\n#define INF 1000000000 \n\t\t\nint main(){\n\tint N;\n\tcin>>N;\n\twhile (N--){\n\t\tunordered_map<char, int> um;\n\t\tint K;\n\t\tcin>>K;\n\t\twhile (K--){\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin>>c>>d;\n\t\t\tum[c] = d;\n\t\t}\n\t\tint M,ans = 0;\n\t\tcin>>M;\n\t\tcin.ignore();\n\t\tchar c;\n\t\twhile (c = getchar()){\n\t\t\tif (c == '\\n') M--;\n\t\t\tif (M == 0) break;\n\t\t\tif (um.find(c) != um.end()){\n\t\t\t\tans += um[c];\n\t\t\t}\n\t\t}\n\t\tcout<<fixed<<setprecision(2)<<ans/100.0<<'$'<<endl;\n\t}\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10945 - Mother bear","url":"/2017/09/26/UVA-10945-Mother-bear/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1886\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nwhile True:\n    s = input()\n    if s == \"DONE\":\n        break\n    s = s.translate(str.maketrans('', '', '.,!? ')).lower()\n    if s[::-1] != s:\n        print(\"Uh oh..\")\n    else:\n        print(\"You won't be eaten!\")\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10931 - Parity","url":"/2017/09/26/UVA-10931-Parity/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1872\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <bitset>\n#include <string>\nusing namespace std;\n\nunsigned int int_to_int(unsigned int k) {\n    return (k == 0 || k == 1 ? k : ((k % 2) + 10 * int_to_int(k / 2)));\n}\n\nint main(){\n\tunsigned int i,bcnt;\n\tcout<<int_to_int(3)<<endl;\n\twhile(cin>>i,i){\n\t\tbitset<32> bs(i);\n\t\tstring s = bs.to_string(); \n\t\tcout<<\"The parity of \"<<s.substr(s.find('1'))<<\" is \"<<bs.count()<<\" (mod 2).\"<<endl;\n\t}\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11727 - Cost Cutting","url":"/2017/09/23/UVA-11727-Cost-Cutting/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2827\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nT = int(input())\n\nfor i in range(T):\n    l = [int(x) for x in input().split(' ')]\n    l.sort()\n    print(\"Case {}: {}\".format(i + 1, l[1]))\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10141 - Request for Proposal","url":"/2017/09/23/UVA-10141-Request-for-Proposal/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1082\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\nusing namespace std;\n#define INF 1000000000 \n\nint main(){\tint n,p,ind = 0;\n\twhile (cin>>n>>p, n+p != 0){\n\t\tif (ind != 0) cout<<endl;\n\t\tind ++ ;\n\t\tint maxc = -1;\n\t\tdouble minp = INF;\n\t\tcin.ignore();\n\t\tstring s,ans,name;\n\t\twhile (n--)\n\t\t\tgetline(cin,s);\n\t\twhile (p--){\n\t\t\tdouble d;\n\t\t\tint r;\n\t\t\tgetline(cin,name);\n\t\t\tcin>>d>>r;\n\t\t\tcin.ignore();\n\t\t\tfor (int i = 0 ; i < r; i++){\n\t\t\t\tgetline(cin,s);\n\t\t\t}\n\t\t\tif (r > maxc || (r == maxc && d < minp)){\n\t\t\t\tmaxc = r;\n\t\t\t\tans = name;\n\t\t\t\tminp = d;\n\t\t\t}\n\t\t}\n\t\tcout<<\"RFP #\"<<ind<<endl;\n\t\tcout<<ans<<endl;\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11559 - Event Planning","url":"/2017/09/23/UVA-11559-Event-Planning/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2595\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#define INF 1000000000 \n\t\t\nint main(){\n\tint N,B,H,W;\n\twhile (cin>>N>>B>>H>>W){\n\t\tint min = INF;\n\t\twhile(H--){\n\t\t\tint p,a;\n\t\t\tcin>>p,a;\n\t\t\tfor (int i = 0; i < W; ++i)\t{\n\t\t\t\tcin>>a;\n\t\t\t\tif (a >= N && (N * p) <= B && (N * p) <  min) min = N*p;\n\t\t\t}\n\t\t}\n\t\tmin==INF?cout<<\"stay home\"<<endl:cout<<min<<endl;\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10114 - Loansome Car Buyer","url":"/2017/09/23/UVA-10114-Loansome-Car-Buyer/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1055\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#define INF 1000000000 \n\t\t\nint main(){\n\tint a,d;\n\tdouble b,c;\n\twhile (cin>>a>>b>>c>>d){\n\t\tif (a < 0) break;\n\t\tdouble g,h,k;\n\t\tg = c;\n\t\th = c + b;\n\t\tk = c / a;\n\t\t//cout<<\"hh: \"<<h<<endl;\n\t\tint e,month = 0;\n\t\tbool flag = true;\n\t\tcin>>e;\n\t\tfor (int i = 0; i < d; i++){\n\t\t\tdouble f;\n\t\t\tcin>>f;\n\t\t\tif (i != d-1) cin>>e;\n\t\t\telse e = a;\n\n\t\t\tfor (; month < e && flag; month++){\n\t\t\t\tif (month != 0) g -= k;\n\t\t\t\th *= (1-f);\n\t\t\t\t//cout<<\"e: \"<<e<<endl;\n\t\t\t\t//cout<<\"month: \"<<month<<endl;\n\t\t\t\t//cout<<\"g: \"<<g<<endl;\n\t\t\t\t//cout<<\"h: \"<<h<<endl;\n\t\t\t\t//cout<<\"f: \"<<f<<endl;\n\t\t\t\t\n\t\t\t\tif (h > g) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tmonth == 1?cout<<\"1 month\"<<endl:cout<<month<<\" months\"<<endl;\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10079 - Pizza Cutting","url":"/2017/09/21/UVA-10079-Pizza-Cutting/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1020\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nwhile True:\n    a = int(input())\n    if a < 0:\n        break\n    else:\n        print((1 + a) * a // 2 + 1)\n\n```\n","tags":["UVA"]},{"title":"[UVA] 10783 - Odd Sum","url":"/2017/09/20/UVA-10783-Odd-Sum/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1724\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#define INF 1000000000 \n\t\t\nint main(){\n\tint a;\n\tcin>>a;\n\tfor (int i = 1; i <= a; ++i)\t{\n\t\tint b,c;\n\t\tcin>>b>>c;\n\t\tif (b%2 == 1 && c%2==0)\n\t\t\tc-=1;\n\t\telse if (b%2 == 0 && c%2 == 1)\n\t\t\tb+=1;\n\t\telse if (b%2==0 && c%2 == 0)\n\t\t\tc-=1,b+=1;\n\t\tcout<<\"Case \"<<i<<\": \"<<((b+c)*((c-b+1)/2+1))/2<<endl;\n\t}\n\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10038 - Jolly Jumpers","url":"/2017/09/20/UVA-10038-Jolly-Jumpers/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=979\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <sstream> \n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tstring s;\n\twhile (getline(cin,s)){\n\t\tstringstream ss(s);\n\t\tint num,last,temp,n;\n\t\tbool start = true;\n\t\tss >> n;\n\t\tvector <bool> v(n);\n\t\twhile (ss >> num){\n\t\t\t\tif (!start){\n\t\t\t\t\ttemp = abs(num-last);\n\t\t\t\t\tv[temp] = true;\n\t\t\t\t\tlast = num;\n\t\t\t\t}\n\t\t\t\telse last = num, start = false;\n\t\t\t}\n\t\tbool jolly = true;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tif (v[i] == false){\n\t\t\t\tjolly = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tjolly?cout<<\"Jolly\"<<endl:cout<<\"Not jolly\"<<endl;\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10252 - Common Permutation","url":"/2017/09/11/UVA-10252-Common-Permutation/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1193\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(){\n\tstring a,b;\n\twhile (true,cin.peek()!=EOF){\n\t\t getline(cin,a);\n\t\t getline(cin,b);\n\t\tint cnt1[26]={},cnt2[26]={};\n\t\tfor (int i=0;i<a.length();i++)\n\t\t\tcnt1[a[i]-'a']++;\n\t\tfor (int i=0;i<b.length();i++)\n\t\t\tif (cnt1[b[i]-'a'])\n\t\t\t\tcnt1[b[i]-'a']--,cnt2[b[i]-'a']++;\n\t\tfor (int i=0;i<26;i++)\n\t\t\tfor (int j=0;j<cnt2[i];j++)\n\t\t\t\tcout<<(char)(i+'a');\n\t\tcout<<endl;\n\t}\n\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10137 - The Trip","url":"/2017/09/10/UVA-10137-The-Trip/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1078\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint num[10000]={},i=0,n,j;\n\twhile (cin>>n){  \n\t\tfor (j = 0; j < i; j++)\n\t\t\tif (n<num[j]) break;\n\t\tfor (int k = i+1; k > j-1; k--)\n\t\t\tnum[k] = num[k-1];\n\t\tnum[j]=n;\n\t\ti%2?cout<<(num[(i+1)/2]+num[(i-1)/2])/2<<endl:cout<<num[i/2]<<endl;\n\t\ti++;\n\t}\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 272 - TEX Quotes","url":"/2017/09/05/UVA-272-TEX-Quotes/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=208\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\t\n\tbool br = false;\n\tbool flag=true;\n\tstring s;\n\twhile (getline(cin,s)){\n\t\t//if (br) cout<<endl;\n\t\tbr = true;\n\t\tint l = s.length();\n\t\tfor(int i=  0; i < l; i++){\n\t\t\tif (s[i]!='\\\"') cout<<s[i];\n\t\t\telse if (flag) {\n\t\t\t\tcout<<\"``\";\n\t\t\t\tflag = !flag;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout<<\"\\'\\'\";\n\t\t\t\tflag = !flag;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 568 - Just the Facts","url":"/2017/08/12/UVA-568-Just-the-Facts/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=509\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```python\nimport math\n\n\nwhile True:\n\ttry:\n\t\ta = input()\n\t\ta = int (a)\n\t\tb = str(math.factorial(a))\n\t\tfor i in range(len(b)-1,-1,-1):\n\t\t\tif b[i] != '0':\n\t\t\t\tprint ('{:>5} -> {:1}'.format(a,b[i]))\n\t\t\t\tbreak\n\texcept Exception as e:\n\t\tbreak\n\t\n\n\n```\n","tags":["UVA"]},{"title":"[UVA] 140 - Bandwidth","url":"/2017/07/30/UVA-140-Bandwidth/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=76\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nvector <int> v[26],node,path,band,ans;\nint visit[26], depth = 1, min_band = 1000, size;\n\nvoid dfs(int n){\n\tdepth++;\n\tpath.push_back(n);\n\tvisit[n] = depth;\n\n\tint temp = 0;\n\tfor (auto i:v[n])\n\t\tif (visit[i]) temp = max (temp, depth - visit[i]);\n\n\tif (band.empty()) band.push_back(temp);\n\telse band.push_back(max(temp,band.back()));\n\n\tif (band.back() < min_band && depth == size) {\n\t\tans = path;\n\t\tmin_band = band.back();\n\t}\n\n\tfor (auto i:node)\n\t\tif (!visit[i]) dfs(i);\n\n\tpath.pop_back();\n\tband.pop_back();\n\tvisit[n] = false;\n\tdepth --;\n}\n\nint main(int argc, char const *argv[])\n{\n\twhile (cin.peek() != '#'){\n\t\tmemset(visit,0,sizeof(visit));\n\n\t\tchar ch,ch1;\n\t\tbool flag = false;\n\t\tfor (auto &i:v)\n\t\t\ti.clear();\n\t\tnode.clear();\n\t\tdepth = 1, min_band = 1000, size = 0;\n\n\t\twhile (ch = cin.get(), ch != '\\n'){\n\t\t\tif (ch == ':') flag = true;\n\t\t\telse if (ch == ';') flag = false;\n\t\t\telse if (!flag) {\n\t\t\t\tch1 = ch;\n\t\t\t\tvisit[ch-'A'] = true;\n\t\t\t}\n\t\t\telse if (flag) {\n\t\t\t\tif (find(v[ch1-'A'].begin(),v[ch1-'A'].end(),ch-'A') == v[ch1-'A'].end())\n\t\t\t\t\tv[ch1-'A'].push_back(ch-'A');\n\t\t\t\tif (find(v[ch-'A'].begin(),v[ch-'A'].end(),ch1-'A') == v[ch-'A'].end())\n\t\t\t\t\tv[ch-'A'].push_back(ch1-'A');\n\t\t\t\tvisit[ch-'A'] = true;\n\t\t\t}\n\t\t}\t\n\n\t\tfor (int i = 0; i < 26; i++)\n\t\t\tif (visit[i]) node.push_back(i),size++;\n\t\tsize++;\n\t\tmemset(visit,0,sizeof(visit));\n\t\n\t\tfor (auto i:node)\n\t\t\tdfs(i);\n\n\t\tfor (auto i:ans)\n\t\t\tcout<<char(i+'A')<<' ';\n\t\tcout<<\"-> \"<<min_band<<endl;\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 482 - Permutation Arrays","url":"/2017/07/30/UVA-482-Permutation-Arrays/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=423\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nclass data{\npublic:\n\tdata(int a);\n\tbool operator < (const data& other);\n\tint a;\n\tstring b;\n};\n\ndata::data(int a){\n\tthis->a = a;\n\tthis->b = \"\";\n}\n\n\nbool data::operator < (const data& other){\n\treturn (a < other.a);\n}\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tbool first = true;\n\tcin>>n;\n\tcin.ignore();\n\twhile (n--){\n\t\tif(!first) cout<<endl;\n\t\tfirst = false;\n\t\tcin.ignore();\n\t\tstring s;\n\t\tvector <data> v;\n\t\tint a;\n\t\tstring b;\n\t\tgetline(cin,s);\n\t\tstringstream ss1(s);\n\t\twhile (ss1>>a)\n\t\t\tv.push_back(data(a));\n\t\tgetline(cin,s);\n\t\tstringstream ss2(s);\n\t\tfor (int i = 0; ss2>>b; i++)\n\t\t\tv[i].b = b;\n\t\tsort(v.begin(), v.end());\n\t\tfor (auto i:v)\n\t\t\tcout<<i.b<<endl;\n\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 484 - The Department of Redundancy Department","url":"/2017/07/30/UVA-484-The-Department-of-Redundancy-Department/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=425\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint a;\n\tunordered_map <int,int> um;\n\tunordered_map <int,bool> um2;\n\tvector <int> v;\n\twhile (cin>>a){\n\t\tv.push_back(a);\n\t\ttry {\n\t\t\tum.at(a)++;\n\t\t}\n\t\tcatch(exception& e){\n\t\t\tum[a] = 1;\n\t\t}\n\t}\n\tfor (auto i:v){\n\t\ttry{\n\t\t\tum2.at(i);\n\t\t}\n\t\tcatch (exception& e){\n\t\t\tum2[i] = true;\n\t\t\tcout<<i<<' '<<um[i]<<endl;\n\t\t}\n\t}\n\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 12207 - That is Your Queue","url":"/2017/07/30/UVA-12207-That-is-Your-Queue/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3359\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint p,c,ca = 1;\t\n\twhile (cin>>p>>c, p!=0 && c!=0){\n\t\tcout<<\"Case \"<<ca<<':'<<endl;\n\t\tca++;\n\t\tdeque <int> dq;\n\t\tfor (int i = 1; i <= min(p,c); i++)\n\t\t\tdq.push_back(i);\n\t\twhile (c--){\n\t\t\tchar ch;\n\t\t\tcin>>ch;\n\t\t\tif (ch == 'N'){\n\t\t\t\tcout<<dq.front()<<endl;\n\t\t\t\tdq.push_back(dq.front());\n\t\t\t\tdq.pop_front();\n\t\t\t}\n\t\t\telse if (ch == 'E'){\n\t\t\t\tint e;\n\t\t\t\tcin>>e;\n\t\t\t\tdq.push_front(e);\n\t\t\t\tfor (deque<int>::iterator it = dq.begin()+1; it != dq.end(); it++){\n\t\t\t\t\tif (*it == e){\n\t\t\t\t\t\tdq.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10152 - ShellSort","url":"/2017/07/29/UVA-10152-ShellSort/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1093\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint k;\n\tcin>>k;\n\twhile (k--){\n\t\tint n, i, j;\n\t\tvector <string> v1,v2;\n\t\tstring s;\n\t\tcin>>n;\n\t\tcin.ignore();\n\t\tfor (i = 0; i < n; ++i){\n\t\t\tgetline(cin,s);\n\t\t\tv1.push_back(s);\n\t\t}\n\t\tfor (i = 0; i < n; ++i){\n\t\t\tgetline(cin,s);\n\t\t\tv2.push_back(s);\n\t\t}\n\t\tj = n-1;\n\t\tfor (i = n-1; i >= 0; i--)\n\t\t\tif (v2[j] == v1[i]) j--;\n\t\tfor (; j >= 0; j--)\n\t\t\tcout<<v2[j]<<endl;\n\t\tcout<<endl;\n\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 12100 - Printer Queue","url":"/2017/07/29/UVA-12100-Printer-Queue/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3252\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nclass job\n{\n\tpublic:\n\t\tjob(int p, bool a);\n\t\tint priority;\n\t\tbool ans;\n};\n\njob::job(int p, bool a){\n\tpriority = p;\n\tans =a ;\n}\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tcin>>n;\n\twhile (n--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tqueue <job> q;\n\t\tpriority_queue <int> pq;\n\t\tfor (int i = 0; i < a; ++i){\n\t\t\tint temp;\n\t\t\tcin>>temp;\n\t\t\tpq.push(temp);\n\t\t\tif (i == b)\n\t\t\t\tq.push(job(temp,1));\n\t\t\telse q.push(job(temp,0));\n\t\t}\n\n\t\tint time = 0;\n\t\twhile (1){\n\t\t\tif (q.front().priority == pq.top()){\n\t\t\t\tif (q.front().ans == 1){\n\t\t\t\t\ttime ++;\n\t\t\t\t\tcout<<time<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tpq.pop();\n\t\t\t\t\tq.pop();\n\t\t\t\t\ttime++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tq.push(q.front());\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n```\n","tags":["UVA"]},{"title":"[UVA] 11716 - Digital Fortress","url":"/2017/07/29/UVA-11716-Digital-Fortress/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2763\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tcin>>n;\n\tcin.ignore();\n\twhile (n--){\n\t\tstring s;\n\t\tint temp;\n\t\tgetline(cin,s);\n\t\ttemp = sqrt(s.length());\n\t\tif (temp*temp != s.length()){\n\t\t\tcout<<\"INVALID\"<<endl;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < temp; ++i){\n\t\t\t\tfor (int j = 0; j < temp; j++){\n\t\t\t\t\tcout<<s[i+j*temp];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 11142 - MineSweeper II","url":"/2017/07/27/UVA-11142-MineSweeper-II/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2083\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <cstring>\n#include <cctype>\n#include <queue>\n#include <bitset>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint n,ca=1;\n\tbool first = true;\n\tint da[8] = {-1,-1,-1,0,0,1,1,1}, db[8] = {-1,0,1,-1,1,-1,0,1};\n\tcin>>n;\n\twhile (n--){\n\t\t//init\n\t\tif (!first) cout<<endl;\n\t\tfirst = false;\n\t\tcout<<\"Case #\"<<ca<<':'<<endl;\n\t\tca++;\n\t\tint a,b,c;\n\t\tchar mine[15][15],ch;\n\t\t//char guess[15][15];\n\t\tbool visit[15][15];\n\t\tmemset (mine,0,sizeof(mine));\n\t\t//memset (guess,'0',sizeof(guess));\n\t\tmemset (visit,0,sizeof(visit));\n\n\t\t//input process\n\t\tcin>>a>>b>>c;\n\t\tint remain_mine = c, all_dot = 0;\n\t\tfor (int i = 1; i <= a; i++){\n\t\t\tcin.ignore();\n\t\t\tfor (int j = 1; j <= b; j++){\n\t\t\t\tch = cin.get();\n\t\t\t\tmine[i][j] = ch;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//straightforward method\n\t\tfor (int i = 1; i <= a; i++){\n\t\t\tfor (int j = 1; j <= b; j++){\n\t\t\t\tif (mine[i][j] == 'X') remain_mine--;\n\t\t\t\tif (mine[i][j] == '.') all_dot++;\n\t\t\t\tif (isdigit(mine[i][j])){\n\t\t\t\t\tint X_cnt = 0,dot_cnt=0,cnt = mine[i][j] - '0';\n\t\t\t\t\tfor (int k = 0; k < 8; k++){\n\t\t\t\t\t\tif (mine[i + da[k]][j + db[k]]   == '.') dot_cnt++;\t\n\t\t\t\t\t\tif (mine[i + da[k]][j + db[k]]   == 'X') X_cnt++;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt - X_cnt == 0)\n\t\t\t\t\t\tfor (int k = 0; k < 8; k++)\n\t\t\t\t\t\t\tif (mine[i + da[k]][j + db[k]]   == '.') mine[i + da[k]][j + db[k]] = 'F', all_dot--;\n\t\t\t\t\tif (cnt - X_cnt == dot_cnt)\n\t\t\t\t\t\tfor (int k = 0; k < 8; k++)\n\t\t\t\t\t\t\tif (mine[i + da[k]][j + db[k]]   == '.') mine[i + da[k]][j + db[k]] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\tint mine_cnt = 0;\n\t\tfor (int i = 1; i <= a; i++)\n\t\t\tfor (int j = 1; j <= b; j++){\n\t\t\t\tif ((isdigit (mine[i-1][j]  ) || isdigit (mine[i-1][j-1]) || isdigit (mine[i][j-1]  ) || isdigit (mine[i+1][j]  ) || isdigit (mine[i][j+1]  ) || isdigit (mine[i+1][j+1]) || isdigit (mine[i-1][j+1]) || isdigit (mine[i+1][j-1])) && mine[i][j] == '.')\n\t\t\t\t\tmine[i][j] = 'G';\n\t\t\t\tif (mine[i][j] == 'X') mine_cnt++;\n\t\t\t}\n\n\t/**cout<<\"mine_cnt: \"<<mine_cnt<<endl;\n\t\tfor (int i = 1; i <= a; i++){\n\t\t\tfor (int j = 1; j <= b; j++){\n\t\t\t\tif (mine[i][j] == 'G') guess[i][j] = 'G';\n\t\t\t//\tif (isdigit(mine[i][j])) guess[i][j] = '2';\n\t\t\t//\tif (mine[i][j] == '0') guess[i][j] = '0';\n\t\t\t}\n\t\t}\t**/\t\n\n\t\tfor (int i = 1; i <= a; i++){\n\t\t\tfor (int j = 1; j <= b; j++){\n\t\t\t\tcout<<mine[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;\n\n\t\tbool guessed[15][15];\n\t\tvector <vector <int> > vx,vy;\n\t\tmemset (guessed,0,sizeof(guessed));\n\t\tfor (int ga = 1; ga <= a; ga++){\n\t\t\tfor (int gb = 1; gb <= b; gb++){\n\t\t\t\tif (!guessed[ga][gb]){\n\t\t\t\t\tguessed[ga][gb] = true;\n\t\t\t\t\tqueue <int> qx,qy;\n\t\t\t\t\tvector <int> vtx,vty;\n\t\t\t\t\tint x,y;\n\t\t\t\t\tqx.push(ga);\n\t\t\t\t\tqy.push(gb);\n\t\t\t\t\twhile (!qx.empty()){\n\t\t\t\t\t\tx = qx.front();\n\t\t\t\t\t\ty = qy.front();\n\t\t\t\t\t\t//cout<<'('<<x<<','<<y<<')'<<endl;\n\t\t\t\t\t\tif (mine[x][y] == 'G'){\n\t\t\t\t\t\t\tvtx.push_back(x);\n\t\t\t\t\t\t\tvty.push_back(y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqx.pop();\n\t\t\t\t\t\tqy.pop();\n\t\t\t\t\t\tvisit[x][y] = true;\n\t\t\t\t\t\tfor (int k = 0; k < 8; k++){\n\t\t\t\t\t\t//10\tcout<<\"checking\"<<'('<<x + da[k]<<','<<y + db[k]<<')'<<endl;\n\t\t\t\t\t\t\tguessed[x + da[k]][y + db[k]] = true;\n\t\t\t\t\t\t\tif (!visit[x + da[k]][y + db[k]] && mine[x + da[k]][y + db[k]] == 'G'){\n\t\t\t\t\t\t//\t\tcout<<'('<<x + da[k]<<','<<y + db[k]<<')'<<\"OK\"<<endl;\n\t\t\t\t\t\t\t\tqx.push(x + da[k]);\n\t\t\t\t\t\t\t\tqy.push(y + db[k]);\n\t\t\t\t\t\t\t\tvisit[x + da[k]][y + db[k]] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout<<\"=============\"<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tif (!vtx.empty()){\n\t\t\t\t\t\tvx.push_back(vtx);\n\t\t\t\t\t\tvy.push_back(vty);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < vx.size(); i++){\n\t\t\tfor (int j=0; j < vx[i].size(); j++){\n\t\t\t\tcout<<'('<<vx[i][j]<<','<<vy[i][j]<<\") \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\n\t\tfor (int i = 0; i < vx.size(); i++){\n\t\t\tchar mine_guess[15][15]={};\n\t\t\tbool checked[15][15]={};\n\n\t\t\tvector <int> checkx, checky;\n\t\t\tfor (int j = 0; j < vx[i].size(); j++){\n\t\t\t\tfor (int k = 0; k < 8; k++)\n\t\t\t\t\tif (isdigit (mine[vx[i][j] + da[k]][vy[i][j] + db[k]] ) && !checked[vx[i][j] + da[k]][vy[i][j] + db[k]]) {\n\t\t\t\t\t\t//cout<<'('<<vx[i][j] + da[k]<<','<<vy[i][j] + db[k]<<')'<<endl;\n\t\t\t\t\t\tcheckx.push_back(vx[i][j] + da[k]);\n\t\t\t\t\t\tchecky.push_back(vy[i][j] + db[k]);\n\t\t\t\t\t\tchecked[vx[i][j] + da[k]][vy[i][j] + db[k]] = true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvector <int> ok_cob(vx[i].size() , -1);\n\t\t    for (int j = 0; j < (1 << vx[i].size()); j++){\n\t\t        bitset<1048576> bit (j);\n        \t\t//cout<<bit<<endl;\n\n        \t\t/*\n        \t\tfor (int k =0; k < vx[i].size(); k++)\n        \t\t\tcout<<bit[k];\n        \t\tcout<<endl;\n        \t\t*/\n\t\t        int this_mine = 0;\n        \t\tfor (int ii = 1; ii <= a; ii++){\n        \t\t\tfor (int jj = 1; jj <= b; jj++){ \n        \t\t\t\t\tmine_guess[ii][jj] = mine [ii][jj];\n        \t\t\t}\n        \t\t}\n\n          \t\tfor (int ii = 0; ii < vx[i].size(); ii++){\n          \t\t\tif (bit[ii]) {\n          \t\t\t\tmine_guess[vx[i][ii]][vy[i][ii]] = 'X';\n          \t\t\t\tthis_mine++;\n          \t\t\t}\n          \t\t}\n          \t\t//cout<<\"remain_mine: \"<<remain_mine<<endl;\n\n          \t\tif (all_dot - vx[i].size() < remain_mine - this_mine) continue;\n          \t\t/*for (int ii=0; ii < checkx.size(); ii++){\n          \t\t\tint cx = checkx[ii], cy = checky[ii];\n\t\t\t\t\tint X_cnt = 0,dot_cnt=0,cnt = mine_guess[cx][cy] - '0';\n\t\t\t\t\tfor (int k = 0; k < 8; k++){\n\t\t\t\t\t\tif (mine_guess[cx + da[k]][cy + db[k]]   == '.') dot_cnt++;\t\n\t\t\t\t\t\tif (mine_guess[cx + da[k]][cy + db[k]]   == 'X') X_cnt++;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt - X_cnt == 0){\n\t\t\t\t\t\t//cout<<\"OK\"<<endl;\n\t\t\t\t\t\tfor (int iii = 1; iii <= a; iii++){\n\t\t\t\t\t\t\tfor (int jjj = 1; jjj <= b; jjj++){\n\t\t\t\t\t\t\t\tcout<<mine_guess[iii][jjj];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout<<endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout<<endl;\n\t\t\t\t\t}\n          \t\t}*/\n\n          \t\tbool ok = true;\n          \t\tfor (int ii=0; ii < checkx.size(); ii++){\n          \t\t\tint cx = checkx[ii], cy = checky[ii], X_cnt = 0, cnt = mine_guess[cx][cy] - '0';\n          \t\t\tfor (int k = 0; k < 8; k++)\n          \t\t\t\tif (mine_guess[cx + da[k]][cy + db[k]]   == 'X') X_cnt++;\t\n          \t\t\t//cout<<cx<<' '<<cy<<' '<<cnt<<' '<<X_cnt<<endl;\n          \t\t\tif (cnt != X_cnt) ok = false;\n          \t\t}\n\n          \t\tif (ok){\n\t          \t\tfor (int ii = 0; ii < vx[i].size(); ii++){\n\t          \t\t\t//cout<<\"ok_cob[ii]: \"<<ok_cob[ii]<<endl;\n\t          \t\t\t//cout<<\"bit[ii]: \"<<int(bit[ii])<<endl;\n\t          \t\t\tif (ok_cob[ii] == -1) ok_cob[ii] = int(bit[ii]);\n\t          \t\t\telse if (ok_cob[ii] != bit[ii]) {\n\t          \t\t\t\tok_cob[ii] = -2;\n\t          \t\t\t}\n\n\t          \t\t}\n          \t\t}\n\n          \t\tbool gameover = true;\n          \t\tfor (auto gg:ok_cob){\n          \t\t\tif (gg ==-1 || gg == 1) {\n          \t\t\t\tgameover = false;\n          \t\t\t\tbreak;\n          \t\t\t}\n          \t\t}\n          \t\tif (gameover) break;\n\n          \t\t\n          \t\tif (ok){\n\t\t\t\t\tcout<<\"debug=======\"<<endl;\n\t\t\t\t\tfor (int i = 1; i <= a; i++){\n\t\t\t\t\t\tfor (int j = 1; j <= b; j++){\n\t\t\t\t\t\t\tcout<<mine_guess[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\n\t\t\t\t\n    \t\t}\n\n    \t\tfor (int ii = 0; ii < vx[i].size(); ii++){\n    \t\t\tif (ok_cob[ii] == 1) mine[vx[i][ii]][vy[i][ii]] = 'X';\n    \t\t}\n    \t\t//for (auto apple:ok_cob)\n    \t\t//\tcout<<apple<<\" \";\n    \t\t//cout<<endl;\n\t\t\t/*for (int j=0; j < vx[i].size(); j++){\n\t\t\t\tcout<<'('<<vx[i][j]<<','<<vy[i][j]<<\") \";\n\n\t\t\t}*/\n\t\t\t//cout<<endl;\n\t\t}\n\n/*\n\t\tcout<<\"debug=======\"<<endl;\n\t\tfor (int i = 1; i <= a; i++){\n\t\t\tfor (int j = 1; j <= b; j++){\n\t\t\t\tcout<<mine[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;\n*/\n\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 401 - Palindromes","url":"/2017/07/27/UVA-401-Palindromes/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=342\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nchar mirrorChar (char c){\n\tswitch(c){\n\t\tcase 'A':\n\t\t\treturn 'A';\n\t\tcase 'E':\n\t\t\treturn '3';\n\t\tcase 'H':\n\t\t\treturn 'H';\n\t\tcase 'I':\n\t\t\treturn 'I';\n\t\tcase 'J':\n\t\t\treturn 'L';\n\t\tcase 'L':\n\t\t\treturn 'J';\n\t\tcase 'M':\n\t\t\treturn 'M';\n\t\tcase 'O':\n\t\t\treturn 'O';\n\t\tcase 'S':\n\t\t\treturn '2';\n\t\tcase 'T':\n\t\t\treturn 'T';\n\t\tcase 'U':\n\t\t\treturn 'U';\n\t\tcase 'V':\n\t\t\treturn 'V';\n\t\tcase 'W':\n\t\t\treturn 'W';\n\t\tcase 'X':\n\t\t\treturn 'X';\n\t\tcase 'Y':\n\t\t\treturn 'Y';\n\t\tcase 'Z':\n\t\t\treturn '5';\n\t\tcase '1':\n\t\t\treturn '1';\n\t\tcase '2':\n\t\t\treturn 'S';\n\t\tcase '3':\n\t\t\treturn 'E';\n\t\tcase '5':\n\t\t\treturn 'Z';\n\t\tcase '8':\n\t\t\treturn '8';\n\t\tdefault:\n\t\t\treturn '-';\n\t\t}\n}\n\nint main(int argc, char const *argv[])\n{\n\tstring s;\n\twhile(cin>>s) {\n\t\tint len = s.length();\n\t\tbool pal=true, mirror=true;\n\t\tfor (int i=0;i*2<len;i++){\n\t\t\tif (s[i]!=s[len-i-1]) pal=false;\n\t\t\tif (s[i]!=mirrorChar(s[len-i-1])) mirror = false;\n\t\t}\n\t\tif (!pal && !mirror)\n\t\t\tcout<<s<<\" -- is not a palindrome.\"<<endl;\n\t\tif (!pal && mirror)\n\t\t\tcout<<s<<\" -- is a mirrored string.\"<<endl;\n\t\tif (pal && !mirror)\n\t\t\tcout<<s<<\" -- is a regular palindrome.\"<<endl;\n\t\tif (pal && mirror)\n\t\t\tcout<<s<<\" -- is a mirrored palindrome.\"<<endl;\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10279 - Mine Sweeper","url":"/2017/07/26/UVA-10279-Mine-Sweeper/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1220\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tbool first = true;\n\tint n,weight, height;\n\tstring s;\n\tchar c,mine[110][110],ans[110][110];\n\tcin>>n;\n\twhile (n--){\n\t\t//cout<<\"n: \"<<n<<endl;\n\t\tif (!first) cout<<endl;\n\t\tfirst = false;\n\t\tbool dead = false;\n\t\tmemset (mine,0,sizeof(mine));\n\t\tmemset (ans,'.',sizeof(ans));\n\t\tcin>>height;\n\t\tcin.ignore();\n\t\tfor (int i = 1; i <= height; i++){\n\t\t\tgetline(cin,s);\n\t\t\t//cout<<\"s: \"<<s<<endl;\n\t\t\tstringstream ss(s);\n\t\t\tweight = s.length();\n\t\t\tfor (int j = 1; j <= weight; j++){\n\t\t\t\tc = ss.get();\n\t\t\t\tmine[i][j] = c;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 1; i <= height; i++){\n\t\t\tgetline(cin,s);\n\t\t\tstringstream ss(s);\n\t\t\tweight = s.length();\n\t\t\tfor (int j = 1; j <= weight; j++){\n\t\t\t\tc = ss.get();\n\t\t\t\t//cout<<\"c: \"<<c<<endl;\n\t\t\t\tif (c == 'x'){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tif (mine[i][j] == '*') {\n\t\t\t\t\t\tdead = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (mine[i-1][j] == '*') cnt++;\n\t\t\t\t\tif (mine[i-1][j-1] == '*') cnt++;\n\t\t\t\t\tif (mine[i][j-1] == '*') cnt++;\n\t\t\t\t\tif (mine[i+1][j] == '*') cnt++;\n\t\t\t\t\tif (mine[i][j+1] == '*') cnt++;\n\t\t\t\t\tif (mine[i+1][j+1] == '*') cnt++;\n\t\t\t\t\tif (mine[i-1][j+1] == '*') cnt++;\n\t\t\t\t\tif (mine[i+1][j-1] == '*') cnt++;\n\t\t\t\t\tans[i][j] = cnt+'0';\n\t\t\t\t\t//cout<<\"ans[i][j]: \"<<ans[i][j]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (dead){\n\t\t\tfor (int i = 1; i <= height; i++){\n\t\t\t\tfor (int j = 1; j <= weight; j++){\n\t\t\t\t\tif (mine[i][j] == '*') ans[i][j] = '*';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor (int i = 1; i <= height; i++){\n\t\t\tfor (int j = 1;j <= weight; j++)\n\t\t\t\tcout<<ans[i][j];\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10189 - Minesweeper","url":"/2017/07/26/UVA-10189-Minesweeper/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1130\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint a,b,ca = 1;\n\tbool first = true;\n\twhile (cin>>a>>b, a!=0 || b!=0){\n\t\tif (!first) cout<<endl;\n\t\tcout<<\"Field #\"<<ca<<\":\"<<endl;\n\t\tca++;\n\t\tfirst = false;\n\t\tchar mine[110][110],c;\n\t\tint cnt=0;\n\t\tmemset (mine,0,sizeof(mine));\n\t\tfor (int i = 1; i <= a; i++){\n\t\t\tcin.ignore();\n\t\t\tfor (int j = 1; j <= b; j++){\n\t\t\t\tc = cin.get();\n\t\t\t\tmine[i][j] = c;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= a; i++){\n\t\t\tfor (int j = 1; j <= b; j++){\n\t\t\t\tcnt = 0;\n\t\t\t\tif (mine[i][j] == '*') {\n\t\t\t\t\tcout<<'*';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (mine[i-1][j] == '*') cnt++;\n\t\t\t\tif (mine[i-1][j-1] == '*') cnt++;\n\t\t\t\tif (mine[i][j-1] == '*') cnt++;\n\t\t\t\tif (mine[i+1][j] == '*') cnt++;\n\t\t\t\tif (mine[i][j+1] == '*') cnt++;\n\t\t\t\tif (mine[i+1][j+1] == '*') cnt++;\n\t\t\t\tif (mine[i-1][j+1] == '*') cnt++;\n\t\t\t\tif (mine[i+1][j-1] == '*') cnt++;\n\t\t\t\tcout<<cnt;\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10877 - Diceoids","url":"/2017/07/25/UVA-10877-Diceoids/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1818\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass dice\n{\n\tpublic:\n\t\tdice(int s[]);\n\t\tbool operator == (const dice& a);\n\t\tvoid rotate_a();\n\t\tvoid rotate_b();\n\t\tvoid rotate_c();\n\t\tbool compare(dice a);\n\tprivate:\n\t\tint data[6];\n};\n\ndice::dice(int s[]){ //do this becasue of reusing code from uva 253\n\tdata[0] = s[0];\n\tdata[1] = s[1];\n\tdata[3] = s[2];\n\tdata[4] = s[5];\n\tdata[2] = s[4];\n\tdata[5] = s[3];\n}\n\nbool dice::operator == (const dice& a){\n\tfor (int i = 0; i < 6; ++i)\n\t\tif (data[i] != a.data[i])\n\t\t\treturn false;\n\treturn true;\n}\n\nvoid dice::rotate_a (){\n\tint temp = data[2];\n\tdata[2] = data[1];\n\tdata[1] = data[3];\n\tdata[3] = data[4];\n\tdata[4] = temp;\n}\n\nvoid dice::rotate_b (){\n\tint temp = data[0];\n\tdata[0] = data[1];\n\tdata[1] = data[5];\n\tdata[5] = data[4];\n\tdata[4] = temp; \n}\n\nvoid dice::rotate_c(){\n\tint temp = data[0];\n\tdata[0] = data[3];\n\tdata[3] = data[5];\n\tdata[5] = data[2];\n\tdata[2] = temp;\n}\n\nbool dice::compare (dice a){\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tthis->rotate_a();\n\t\t\tif (a == *this) return true;\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tthis->rotate_b();\n\t\t\tif (a == *this) return true;\n\t\t}\n\t\tthis->rotate_c();\n\t}\n\treturn false;\n}\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\twhile (cin>>n,n){\n\t\tint a[6],cnt=0;\n\t\tvector<dice> v1,v2;\n\t\twhile (n--){\n\t\t\tfor (int i = 0; i < 6; ++i)\n\t\t\t\tcin>>a[i];\n\t\t\tv1.push_back(dice(a));\n\t\t}\n\t\tfor (auto i:v1){\n\t\t\tbool flag = true;\n\t\t\tfor (auto j:v2){\n\t\t\t\tif (i.compare(j)){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tv2.push_back(i);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 253 - Cube painting","url":"/2017/07/25/UVA-253-Cube-painting/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=189\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass dice\n{\n\tpublic:\n\t\tdice(string s);\n\t\tbool operator == (const dice& a);\n\t\tvoid rotate_a();\n\t\tvoid rotate_b();\n\t\tvoid rotate_c();\n\t\tbool compare(dice a);\n\tprivate:\n\t\tchar data[6];\n};\n\ndice::dice(string s){\n\tfor (int i = 0; i < 6; ++i)\n\t\tdata[i] = s[i];\n}\n\nbool dice::operator == (const dice& a){\n\tfor (int i = 0; i < 6; ++i)\n\t\tif (data[i] != a.data[i])\n\t\t\treturn false;\n\treturn true;\n}\n\nvoid dice::rotate_a (){\n\tint temp = data[2];\n\tdata[2] = data[1];\n\tdata[1] = data[3];\n\tdata[3] = data[4];\n\tdata[4] = temp;\n}\n\nvoid dice::rotate_b (){\n\tint temp = data[0];\n\tdata[0] = data[1];\n\tdata[1] = data[5];\n\tdata[5] = data[4];\n\tdata[4] = temp; \n}\n\nvoid dice::rotate_c(){\n\tint temp = data[0];\n\tdata[0] = data[3];\n\tdata[3] = data[5];\n\tdata[5] = data[2];\n\tdata[2] = temp;\n}\n\nbool dice::compare (dice a){\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tthis->rotate_a();\n\t\t\tif (a == *this) return true;\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tthis->rotate_b();\n\t\t\tif (a == *this) return true;\n\t\t}\n\t\tthis->rotate_c();\n\t}\n\treturn false;\n}\n\nint main(int argc, char const *argv[])\n{\n\tstring s;\n\twhile (cin>>s){ \n\t\tdice a(s.substr(0,6)),b(s.substr(6,12));\n\t\ta.compare(b)?cout<<\"TRUE\"<<endl:cout<<\"FALSE\"<<endl;\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10550 - Combination Lock","url":"/2017/07/24/UVA-10550-Combination-Lock/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1491\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint a,b,c,d;\n\twhile (cin>>a>>b>>c>>d){\n\t\tint sum=720;\n\t\tsum += (a-b+40)%40*9;\n\t\tsum += 360;\n\t\tsum += (c-b+40)%40*9;\n\t\tsum += (c-d+40)%40*9;\n\t\tif (a+b+c+d == 0) break;\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10267 - Graphical Editor","url":"/2017/07/23/UVA-10267-Graphical-Editor/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1208\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nclass canvas\n{\npublic:\n\tcanvas();\n\tvoid resize(int x, int y);\n\tvoid print();\n\tvoid clear();\n\tvoid color(int x, int y, char c);\n\tvoid draw_vertical(int x, int y1, int y2, char c);\n\tvoid draw_horizontal (int x1, int x2, int y, char c);\n\tvoid fill (int x1, int y1, int x2, int y2, char c);\n\tvoid fill_region(int x, int y, char c);\n\tvoid save(string s);\n\nprivate:\n\tint width,height;\n\tchar table[300][300];\n\tbool travel[300][300];\n};\n\ncanvas::canvas(){\n\tclear();\n}\n\nvoid canvas::print(){\n\tfor (int i = 1; i <= height; ++i){\n\t\tfor (int j = 1; j <= width; ++j)\n\t\t\tcout<<table[i][j];\n\t\tcout<<endl;\n\t}\n}\n\nvoid canvas::clear(){\n\tmemset(table,'O',sizeof(table));\n}\n\nvoid canvas::color(int x, int y, char c){\n\ttable[y][x] = c;\n}\n\nvoid canvas::draw_vertical(int x, int y1, int y2, char c){\n\tif (y1 > y2) swap(y1,y2);\n\tfor (int i = y1; i <= y2; i++)\n\t\tcolor(x,i,c);\n}\n\nvoid canvas::draw_horizontal(int x1, int x2, int y, char c){\n\tif (x1 > x2) swap(x1,x2);\n\tfor (int i = x1; i <= x2; i++)\n\t\tcolor(i,y,c);\n}\n\nvoid canvas::fill (int x1, int y1, int x2, int y2, char c){\n\tfor (int i = y1; i <= y2; i++)\n\t\tdraw_horizontal(x1,x2,i,c);\n}\n\nvoid canvas::save (string s){\n\tcout<<s<<endl;\n\tprint();\n}\n\nvoid canvas::resize (int x, int y){\n\twidth = x;\n\theight = y;\n\tclear();\n}\n\nvoid canvas::fill_region (int x, int y, char c){\n\tqueue <int> qx,qy;\n\tmemset (travel,0,sizeof(travel));\n\tchar org = table[y][x];\n\ttravel[y][x] = true;\n\tqx.push(x);\n\tqy.push(y);\n\twhile (!qx.empty()){\n\t\tint tempx = qx.front(), tempy = qy.front();\n\t\tcolor(tempx, tempy, c);\n\t\tqx.pop();\n\t\tqy.pop();\n\t\tif (tempy-1 > 0 && !travel[tempy-1][tempx] && table[tempy-1][tempx] == org) {\n\t\t\tqx.push(tempx);\n\t\t\tqy.push(tempy-1);\n\t\t\ttravel[tempy-1][tempx] = true;\n\t\t}\n\t\tif (tempx-1 > 0 && !travel[tempy][tempx-1] && table[tempy][tempx-1] == org) {\n\t\t\tqx.push(tempx-1);\n\t\t\tqy.push(tempy);\n\t\t\ttravel[tempy][tempx-1] = true;\n\t\t}\n\t\tif (tempx+1 <= width > 0 && !travel[tempy][tempx+1] && table[tempy][tempx+1] == org) {\n\t\t\tqx.push(tempx+1);\n\t\t\tqy.push(tempy);\n\t\t\ttravel[tempy][tempx+1] = true;\n\t\t}\n\t\tif (tempy+1 <= height > 0 && !travel[tempy+1][tempx] && table[tempy+1][tempx] == org) {\n\t\t\tqx.push(tempx);\n\t\t\tqy.push(tempy+1);\n\t\t\ttravel[tempy+1][tempx] = true;\n\t\t}\n\t\t\t\n\t}\n\n}\n\nint main(int argc, char const *argv[])\n{\n\tstring s;\n\tcanvas can;\n\twhile (getline(cin,s)){\n\t\t//cout<<\"s: \"<<s<<endl;\n\t\tchar ch,e;\n\t\tint a,b,c,d;\n\t\tstringstream ss(s);\n\t\tss>>ch;\n\t\tswitch (ch){\n\t\t\tcase 'C':\n\t\t\t\tcan.clear();\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tss>>a>>b;\n\t\t\t\tcan.resize(a,b);\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tss>>a>>b>>e;\n\t\t\t\tcan.color(a,b,e);\n\t\t\t\tbreak;\n\t\t\tcase 'V':\n\t\t\t\tss>>a>>b>>c>>e;\n\t\t\t\tcan.draw_vertical(a,b,c,e);\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tss>>a>>b>>c>>e;\n\t\t\t\tcan.draw_horizontal(a,b,c,e);\n\t\t\t\tbreak;\n\t\t\tcase 'K':\n\t\t\t\tss>>a>>b>>c>>d>>e;\n\t\t\t\tcan.fill(a,b,c,d,e);\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tss>>a>>b>>e;\n\t\t\t\tcan.fill_region(a,b,e);\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tss>>s;\n\t\t\t\tcan.save(s);\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10370 - Above Average","url":"/2017/07/23/UVA-10370-Above-Average/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1311\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <sstream>\n#include <iostream>\n#include <vector>\n#include <iomanip>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint c;\n\tcin>>c;\n\tcin.ignore();\n\twhile (c--){\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tstringstream ss(s);\n\t\tint n,temp,cnt=0,sum=0;\n\t\tdouble avg;\n\t\tvector<int> v;\n\t\tss>>n;\n\t\tfor (int i=0;i<n;i++){\n\t\t\tss>>temp;\n\t\t\tsum+=temp;\n\t\t\tv.push_back(temp);\n\t\t}\n\t\tavg = (double)sum/n;\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tif (v[i] > avg) cnt++;\n\t\t}\n\t\tcout<<fixed<<setprecision(3)<<((double)cnt/n)*100<<'%'<<endl;\n\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 537 - Artificial Intelligence?","url":"/2017/07/18/UVA-537-Artificial-Intelligence/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=478\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\n#include <regex>\n#include <iomanip>\n\nusing namespace std;\n\ndouble prefix (char c){\n\tswitch (c){\n\t\tcase 'm':\n\t\t\treturn 0.001;\n\t\tcase 'k':\n\t\t\treturn 1000;\n\t\tcase 'M':\n\t\t\treturn 1000000;\n\t\tdefault:\n\t\t\treturn 1;\n\t}\n}\n\nint main(int argc, char const *argv[])\n{\n\tint cnt;\n\tcin>>cnt;\n\tcin.ignore();\n\tfor (int i = 1;i <= cnt; i++){\n\t\tstring s,data1,data2,data1_pre,data2_pre,temp,data1_con,data2_con;\n\t\tdouble ddata1,ddata2;\n\t\tgetline(cin,s);\n\n\t\tsmatch sm;\n\t\tregex e (\"([U|P|I])=([0-9.]*)([m|k|M]?)\");\n\t\tregex_search (s,sm,e);\n\t\tdata1_con = sm[1];\n\t\tdata1 = sm[2];\n\t\tdata1_pre = sm[3];\n\t\ttemp = sm.suffix().str(); \n\t\tregex_search (temp,sm,e);\n\t\tdata2_con = sm[1];\n\t\tdata2 = sm[2];\n\t\tdata2_pre = sm[3];\n\n\t\tcout<<\"Problem #\"<<i<<endl;\n\t\tdouble ans;\n\t\tddata1 = (double)stod(data1)*prefix(data1_pre[0]);\n\t\tddata2 = (double)stod(data2)*prefix(data2_pre[0]);\n\t\tif (data1_con[0] != 'P' && data2_con[0] != 'P'){\n\t\t\tans = ddata1 * ddata2;\n\t\t\tcout<<\"P=\"<<fixed<<setprecision(2)<<ans<<'W'<<endl;\n\t\t}\n\t\tif (data1_con[0] != 'I' && data2_con[0] != 'I'){\n\t\t\tcout<<\"I=\";\n\t\t\tif (data1_con[0] == 'P'){\n\t\t\t\tans = ddata1 / ddata2;\n\t\t\t\tcout<<fixed<<setprecision(2)<<ans<<'A'<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = ddata2 / ddata1;\n\t\t\t\tcout<<fixed<<setprecision(2)<<ans<<'A'<<endl;\n\t\t\t}\n\t\t}\n\t\tif (data1_con[0] != 'U' && data2_con[0] != 'U'){\n\t\t\tcout<<\"U=\";\n\t\t\tif (data1_con[0] == 'P'){\n\t\t\t\tans = ddata1 / ddata2;\n\t\t\t\tcout<<fixed<<setprecision(2)<<ans<<'V'<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = ddata2 / ddata1;\n\t\t\t\tcout<<fixed<<setprecision(2)<<ans<<'V'<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]},{"title":"[UVA] 10361 - Automatic Poetry","url":"/2017/07/18/UVA-10361-Automatic-Poetry/","content":"### 出處\nhttps://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1302\n### 題意\n待補\n### 思路\n待補\n<!--more-->\n### 程式碼\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <regex>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint cnt;\n\tcin>>cnt;\n\tcin.ignore();\n\twhile (cnt--){\n\t\tstring s1, s2, s3, s4, s5, s6, temp;\n\t\tgetline(cin,s1);\n\t\tgetline(cin,s2);\n\t\tfor (auto i:s1)\n\t\t\tif (i != '<' && i != '>')\n\t\t\t\tputchar(i);\n\t\tcout<<endl;\n\n\t\tsmatch sm1;\n\t\tregex e1 (\"<([^>]*)>\");\n\t\tregex_search (s1,sm1,e1);\n\t\ts3 = sm1[1];\n\t\ttemp = sm1.suffix().str();\n\t\tregex_search (temp,sm1,e1);\n\t\ts4 = sm1[1];\n\n\t\tsmatch sm2;\n\t\tregex e2 (\">([^<]*)\");\n\t\tregex_search (s1,sm2,e2);\n\t\ts5 = sm2[1];\n\t\ttemp = sm2.suffix().str();\n\t\tregex_search (temp,sm2,e2);\n\t\ts6 = sm2[1];\n\n\t\tfor (auto i:s2){\n\t\t\tif (i=='.'){\n\t\t\t\tcout<<s4<<s5<<s3<<s6<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse putchar(i);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","tags":["UVA"]}]